\section{Механизм дополнения транзакции}

\label{ch02-expand}

В разделе \ref{ch02-state} определен механизм валидации и применения изменений к состоянию системы. Следует заметить, что изменения вносятся посредством транзакций, представляющие (в соответствии с листингом \ref{lst:tx}) из себя объект-тройку из целочисленного значения, объекта доказательства `proof` и объекта изменений `ChangeSet id value`.
При построении модели блокчейн-системы следует учесть, что коммуникация между узлами сети происходит посредством байт, а не этих абстрактных
объектов.

Процесс преобразования объектов, хранящихся в оперативной памяти в объекты, передаваемые по сети, принято обозначать термином десериализация. Под сериализацией зачастую подразумевается биективное преобразование между некоторым множеством объектов в оперативной памяти и последовтаельностями байт. Тривиальный случай десериализации -- когда биективное преобразование может быть реализовано с помощью чистой функции (не требущей доступа к какому-либо контексту).
Однако в общем случае функция десериализации может требовать доступа к состоянию, в частности представление изменения состояния может быть закодированно компактным способом, требующим получения значений из состояния для однозначного декодирования.

Моделировать этот процесс возможно следующим образом: сериализацию следует проводить в два этапа. Первый этап десериализации проходит без доступа к состоянию, формирует объект доказательства и часть объекта изменений состояния. Второй этап имеет доступ к состоянию, дополняя набор изменений состояния новыми парами (ключ -- изменение значения). В рамках модели мы рассмотрим именно второй этап, здесь и далее называемый дополнением транзакции.

\subsection{Дополнение транзакции общего вида}

Функцию дополнения транзакции можно представить в виде типа `Expander1`. Для десериализации транзакции тогда потребуется конфигурация `Expander1Conf`.

\begin{code}[language=Haskell,label=lst:expander1,caption={Дополнение транзакции общего вида}]
data Expander1 rawTx e id value = Expander1
    { expander1Act :: rawTx -> ERoComp e id value (ChangeSet id value)
    }

data Expander1Conf rawTx e id value proof = Expander1Conf
    { e1cExpander :: Expander1 rawTx e id value
    , e1cDeserialize :: ByteString -> Either e rawTx
    , e1cTypeProof :: rawTx -> (StateTxType, proof)
    }
\end{code}

Тип `Expander1` описывает вычисление в модели состояния. Естественным образом встаёт вопрос о существовании композиции фиксированной глубины для дополнения множества транзакций. В общем случае такой композиции не существует. Вычисление дополнения для очередной транзакции $k$ зависит от состояния, которое будет получено как результат применения предшествующих транзакций $1, .., k - 1$ (см. диаграмму на рисунке \ref{img:expand1}). Как следствие, требуется применить последовательную композицию как минимум $k - 1$ раз, что означает что глубина
композиции не является константной.

TODO вставить диаграму выполнения дополнения общего вида


\subsection{Дополнение транзакции с ограничением}

Фиксированная глубина для композиции вычислений дополнения произвольного множества транзакций, однако, достижима при условии наложения ограничений на вид функции дополнения транзакции. Для получения композиции фиксированной глубины требуется убрать зависимость дополнения транзакции $k$ от результата дополнений предшествующих транзакций $1, .., k - 1$ (см. диаграмму на рисунке \ref{img:expand2}).

Введем тип дополнения транзакции ограниченного вида:

\begin{code}[language=Haskell,label=lst:expander,caption={Дополнение транзакции c ограничением}]
data Expander rawTx e id value = Expander
    { inpSet      :: Set Prefix
    , outSet      :: Set Prefix
    , expanderAct :: rawTx -> ERoComp e id value (ChangeSet id value)
    }
\end{code}
