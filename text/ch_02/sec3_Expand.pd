\section{Механизм дополнения транзакции}

\label{ch02-expand}

В разделе \ref{ch02-state} определен механизм валидации и применения изменений к состоянию системы. Следует заметить, что изменения вносятся посредством транзакций, представляющие (в соответствии с листингом \ref{lst:tx}) из себя объект-тройку из целочисленного значения, объекта доказательства `proof` и объекта изменений `ChangeSet mw rs`.
При построении модели блокчейн-системы следует учесть, что коммуникация между узлами сети происходит посредством байт, а не этих абстрактных
объектов.

Процесс преобразования объектов, хранящихся в оперативной памяти в объекты, передаваемые по сети, принято обозначать термином десериализация. Под сериализацией зачастую подразумевается биективное преобразование между некоторым множеством объектов в оперативной памяти и последовтаельностями байт. Тривиальный случай десериализации -- когда биективное преобразование может быть реализовано с помощью чистой функции (не требущей доступа к какому-либо контексту).
Однако в общем случае функция десериализации может требовать доступа к состоянию, в частности представление изменения состояния может быть закодированно компактным способом, требующим получения значений из состояния для однозначного декодирования.

Моделировать этот процесс возможно следующим образом: сериализацию следует проводить в два этапа. Первый этап десериализации проходит без доступа к состоянию, формирует объект доказательства и часть объекта изменений состояния. Второй этап имеет доступ к состоянию, дополняя набор изменений состояния новыми парами (ключ -- изменение значения). В рамках модели мы рассмотрим именно второй этап, здесь и далее называемый дополнением транзакции.

\subsection{Дополнение транзакции общего вида}

Функцию дополнения транзакции можно представить в виде типа `Expander1`. Для десериализации транзакции тогда потребуется конфигурация `Expander1Conf`.

\begin{code}[language=Haskell,label=lst:expander1,caption={Дополнение транзакции общего вида}]
data Expander1 rawTx e mw rs = Expander1
    { expander1Act :: rawTx -> ERoComp e mw rs (ChangeSet mw rs)
    }

data Expander1Conf rawTx e mw rs proof = Expander1Conf
    { e1cExpander :: Expander1 rawTx e mw rs
    , e1cDeserialize :: ByteString -> Either e rawTx
    , e1cTypeProof :: rawTx -> (StateTxType, proof)
    }
\end{code}

Тип `Expander1` описывает вычисление в модели состояния. Естественным образом встаёт вопрос о существовании композиции фиксированной глубины для дополнения множества транзакций. В общем случае такой композиции не существует. Вычисление дополнения для очередной транзакции $k$ зависит от состояния, которое будет получено как результат применения предшествующих транзакций $1, .., k - 1$ (см. диаграмму на рисунке \ref{img:expand1}). Как следствие, требуется применить последовательную композицию как минимум $k - 1$ раз, что означает что глубина
композиции не является фиксированной.

\subsection{Дополнение транзакции с ограничением}

Фиксированная глубина для композиции вычислений дополнения произвольного множества транзакций, однако, достижима при условии наложения ограничений на вид функции дополнения транзакции. Для получения композиции фиксированной глубины требуется убрать зависимость дополнения транзакции $k$ от результата дополнений предшествующих транзакций $1, .., k - 1$.

В листинге \ref{lst:expander} вводится новый тип дополнения транзакции `Expander`, который позволяет разграничить компоненты состояния, из которых производится чтения от компонент состояния, значения из которых фигурируют в результирующем объекте изменения состояния. Сигнатура и реализация функции `applyExpanderTxsPar` используют идею дополнения транзакции с ограничением: ограничение типа `NotIntersects` гарантирует что компоненты состояния-выход функции дополнения не пересекаются с компонентами
состояниями, из которых функция дополнения производит чтение. Реализация функции `applyExpanderTxsPar` оказывается чрезвычайно простой: с помощью вспомогательной функции для работы с моноидами `mconcat` мы применяем параллельную композицию для функции дополнения, соответственно примененной к каждой транзакции из списка. Глубина полученной композиции не зависит от числа транзакций.

\begin{code}[language=Haskell,label=lst:expander,caption={Дополнение транзакции c ограничением}]
newtype Expander rawTx e mw inRs outRs =
  Expander
    { runExpander :: rawTx -> ERoComp e mw inRs (ChangeSet mw outRs) }

applyExpanderTxsPar
    :: NotIntersects inRs outRs
    => Expander rawTx e mw inRs outRs
    -> [rawTx]
    -> ERoComp e mw inRs [ChangeSet mw outRs]
applyExpanderTxsPar (Expander runExpander)
            = mconcat . map (fmap pure . runExpander)
\end{code}

Однако дополнения транзакции такого вида может быть недостаточно. В частности, может понадобиться произвести процедуру дополнения в несколько этапах, на каждом применяя свою функцию и применяя результаты дополнения предыдущего этапе к состоянию, используемому в настоящем. Это можно представить как последовательность функций дополнения, применяемых к списку транзакций, причем сперва первая функция дополнения применяется ко всем транзакциям из списка, затем вторая и т.д.

В случае использования нескольких последовательных функций дополнения $es$ формула ограничения несколько усложняется:

\begin{equation} \label{restrict-expand-many}
\begin{split}
& \forall e_j \in es \enspace \forall e_{j \geqslant i} \in es
\quad
in \; (e_i) \cap out \; (e_j) = \emptyset
\end{split}
\end{equation}

При условии выполнения формулы \ref{restrict-expand-many} (соответствующее ограничение задаётся аналогично ограничению в листинге \ref{lst:expander}) использование нескольких последовательных функций дополнения по-прежнему позволяет построить композицию фиксированной глубины. На рисунке \ref{img:expand-many} представлена схема выполнения такой композиции (результатам дополнения соответствует список из объектов типа `ChangeSet`, получающийся в результате выполнения всех функций дополнения).

\image{expand-many}{Применение последовательных функций дополнения $E_1$, $E_2$ к списку транзакций}
