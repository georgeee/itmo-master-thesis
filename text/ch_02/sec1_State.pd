\section{Модель локального состояния системы}

\label{ch02-state}

Как было замечено в разделе \ref{ch01:blockchain-applications}, большинство блокчейн-систем представляют из себя распределенные базы данных. В следствие этого, для построения модели блокчейн-системы, следует начать с формализации состояния базы данных, способа его изменения.

\subsection{Тип состояния системы}

Тип `StateP1`, представленный в листинге \ref{lst:statep1}, выражает тип состояния системы. Причем как глобального состояния целиком, так и его части.
Состояние представляется как словарь, отображение из ключа `key` в значение `value`.
И ключ, и значение введены как абстрактные типы. Это позволяет использовать определения для произвольных ключей и значений, используя для разных типов одни и те же полиморфные функции.

\begin{code}[language=Haskell,label=lst:statep1,caption={Тип состояния системы `StateP1`}]
import           Data.Map (Map)

type StateP1 key value = Map key value -- Portion of state
\end{code}

Тип `StateP1` описывает состояние, в котором типы ключа и значения фиксированы и одинаковы для всех компонент одной системы. Это в принципе позволяет описать многокомпонентную систему, даже учитывая различия репрезентации данных в различных компонентов. В частности возможно задать типы ключа и значения как суммы частных типов конкретных компонент, как продемонстрировано в листинге \ref{lst:statep1-example}.
Следует также заметить, что функциям, работающими с данными каких-либо отдельных компонент системы, будет требоваться выбирать из хранилища ключи, созданные интересующим конструктором и проверить соответствие конструктора значения (потенциально завершая исполнение исключением).

\begin{code}[language=Haskell,label=lst:statep1-example,caption={Пример использования структуры состояния: тип-сумма}]
data Address = ..
data PublicKey = ..
data Signature = ..

data ExampleKey1 = EkDlg PublicKey | EkBalances Address

data ExampleValue1 = EvDlg (Address, Signature) | EvBalances Word32
\end{code}

Для написания функций, работающих с отдельными компонентами системы было бы удобно разделять состояние системы на несколько частей, задавая типы для каждой из частей отдельно. Это сделать можно, представляя состояние как тип-произведение нескольких состояний `StateP1` (см. листинг \ref{lst:statep1-example2}), в частности для системы из двух компонент в виже пары.
Однако такое представление имеет существенный минус: требуется использовать конкретные типы, либо зависеть от количества компонент,
что затрудняет реализацию полиморфных функций, работающих с состоянием системы в целом (не частных компонент).

\begin{code}[language=Haskell,label=lst:statep1-example2,caption={Пример использования структуры состояния: тип-произведение}]
type StateP2 =
  ( StateP1 PublicKey (Address, Signature)
  , StateP1 Address Word32
  )

\end{code}

Кроме того, для формализации дополнения транзакций (см. раздел \ref{ch02-expand}) требуется указывать в типе информацию о том, данные каких именно компонент содержаться в объекте состояния. Для разрешения этих затруднений окончательный тип состояния системы `StateP` получился несколько более сложным и для его определения используется ряд продвинутых возможностей системы типов Haskell (в частности семейства типов, поднятие типов до видов).

\begin{code}[language=Haskell,label=lst:statep,caption={Тип состояния системы $StateP$}]
{-# LANGUAGE PolyKinds           #-}
{-# LANGUAGE TypeInType          #-}

import Data.Vynil
import Contol.Lens (iso, Iso')

type StateP (mw :: ((* -> *) -> u -> *)) (rs :: [u]) = Rec (mw Identity) rs

class (Show (K mw t)) =>
  WrappedM (mw :: ((* -> *) -> u -> *)) (t :: u) where
    type K mw t :: *
    type V mw t :: *
    wrappedM' :: forall (g :: * -> *) . Iso' (mw g t) (U g mw t)
    consA :: forall (g :: * -> *) . U g mw t -> mw g t

type U g mw t = Map (K mw t) (g (V mw t))

\end{code}

В определении типа `StateP`, представленном в листинге \ref{lst:statep}, используется тип `Rec` из библиотеки `vinyl` (см. подраздел \ref{ch01-vinyl}). Он позволяет задать гетерогенный список хранилищ различных компонент. Тип `StateP` полагается на существование вида `u`.
Произвольный тип `r`, принадлежащие виду `u`, идентифицирует некую компоненту. Тип `mw` параметризуется типом `g`, в который оборачивается тип-значение, и типом `r`, возвращая тип хранилища для соответствующей `r` компоненте, причем возвращаемый тип изоморфен `Map k (g v)` для некоторых `k`, `v` (соответствующих `r`). Изоморфизм типу `Map k (g v)` задается инстансом класса `WrappedM`.

\begin{code}[language=Haskell,label=lst:statep-ex,caption={Пример использования типа $StateP$}]
{-# LANGUAGE DataKinds           #-}

type family Fst a where Fst '(x,y) = x
type family Snd a where Snd '(x,y) = y

data ExampleStorage = ESBalances | ESDlg
  deriving Show

type family EST (f :: ExampleStorage) :: (*, *) where
  EST 'ESBalances = '(Int, Word16)
  EST 'ESDlg = '(Int, String)

newtype M g f = M { unM :: Map (Fst (EST f)) (g (Snd (EST f))) }

instance (Show (Fst (EST t))) => WrappedM M t where
    type K M t = Fst (EST t)
    type V M t = Snd (EST t)
    wrappedM' = iso unM M
    consA = M

exStateP :: StateP M '[ 'ESDlg]
exStateP = M (M.fromList [ (30, Identity "someValue") ]) :& RNil

exStateP2 :: StateP M '[ 'ESBalances, 'ESDlg]
exStateP2 =
  M (M.fromList [ (30, Identity 1005) ])
    :& M (M.fromList [ (30, Identity "someValue") ]) :& RNil

\end{code}

Для внесения большей ясности в природу типа `StateP` и его параметров, рассмотрим пример использования, представленный в листинге \ref{lst:statep-ex}. Тип данных `ExampleStorage` при включенном расширении `DataKinds` порождает вид `ExampleStorage` с двумя возможными типами: `ESDlg`, `ESBalances`. Семейство типов `EST` задаёт типы ключа и значения.
Тип `M` принимает тип-обертку значения `g :: *-> *` и тип-маркер компоненты `f :: ExampleStorage` и является оберткой над ассоциативным массивом,
представляющим состояние (соответствующий инстанс класса `WrappedM` позволяет получить доступ к объекту типа `Map`).
Значение `exStateP` содержит объект состояния, в котором содержатся ключи компоненты `ESDlg`, в то время как `exStateP2` содержит ключи компонент `ESBalances`, `ESDlg`. Следует заметить, что вследствие того что типы хранилищ задаются семейством типов `EST`, использование неподходящего типа значения приведет к ошибке компиляции.

\subsection{Тип транзакции к состоянию}

Рассмотрим изменение конкретного ключа в состоянии. В листинге \ref{lst:valueop} представлен тип `ValueOp`, представляющий из себя объект-изменение ключа в состоянии. Тип `ValueOp` задает несколько конструкторов. Конструктор `New` создаёт новое значение, `Rem` -- удаляет существующее значение. Конструктор `Upd` обновляет существующее значение (возможно, возвращая ошибку), конструктор `NotExisted` является маркером того что значение не существует (тип `NotExisted` эквивалентен последовательному
применению `New x`, `Rem`). 
Следует заметить, что для типа `ValueOp` нельзя определить композицию, т.к. последовательное применение некоторых конструкторов приводит к ошибке (например, `Rem` и `Upd`). Поэтому задаётся тип `ValueOpEx`, для которого реализуем инстанс `Semigroup`.

\begin{code}[language=Haskell,label=lst:valueop,caption={Изменение значения некоторого ключа}]
data ValueOp v
    = New v
    | Upd v
    | Rem
    | NotExisted
    deriving (Show, Eq)

data ValueOpEx v
    = Op (ValueOp v)
    | Err
    deriving (Show, Eq)

instance Semigroup (ValueOpEx v) where
  (<>) a b = ...
\end{code}

В листинге \ref{lst:changeset} вводится тип изменения состояния. В объекте изменения состояния для каждой компоненты состояние определяется объект типа `Map k (ValueOp v)`, т.е. для некоторого подмножества ключей состояния мы задаём способ их изменения. Требуется заметить, что применение объекта изменений может завершиться ошибкой (например, если ключу, отсутствующему в состоянии, сопоставлено изменение `Rem`).
В листинге \ref{lst:changeset} также представлен тип функции `chgsetMappend`, с помощью которой можно композировать последовательные изменения состояния.
Семейства типов `RecAll`, `RecAll'` используются для установления ограничения на тип для каждого $r \in rs$.

\begin{code}[language=Haskell,label=lst:changeset,caption={Изменение состояния системы}]
type ChangeSet (mw :: ((* -> *) -> u -> *)) (rs :: [u]) = Rec (mw ValueOp) rs

chgsetMappend
  :: forall rs mw .
     ( RecAll' rs (WrappedM mw)
     , Semigroup (Rec (mw ValueOpEx) rs)
     )
  => ChangeSet mw rs -> ChangeSet mw rs -> VerRes String (ChangeSet mw rs)
\end{code}


Транзакция к состоянию представлена в листинге \ref{lst:tx}.
Помимо изменения состояния, транзакция содердит в себе еще два поля: `txType` и `txProof`.
Поле `txType` представляет из себя целочисленный идентификатор типа транзакции.
Поле `txProof` содержит в себе дополнительную информацию, требующуюся валидатору для проверки корректности транзакции.
В частности, для транзакции, изменяющей баланс пользовательского счёта, `txProof`, должен содержать подпись транзакции секретным ключом пользователя-владельца средств.
Поля `txType`, `txProof` будут использованы в последствии в построении валидатора.
Что существенно, поле `txBody` содержит в себе полный набор изменений, которые будут применены к состоянию системы. Ни `txProof`, ни `txType` не будут применены к состоянию, будут забыты как только валидатор их обработает.

\begin{code}[language=Haskell,label=lst:tx,caption={Транзакция}]
newtype StateTxType = StateTxType Int

data StateTx mw rs proof = StateTx
    { txType  :: StateTxType
    , txProof :: proof
    , txBody  :: ChangeSet mw rs
    }
\end{code}

\subsection{Вычисление в модели состояния}

\begin{definition}{Вычисление в модели состояния}
 -- функция, выполняющая последовательность запросов к состоянию для возврата результата.
\end{definition}

Задачей настоящего подразадела является формулировка типа вычисления в модели состояния. При построении типа используются следующие соображения:

* вычисление может выполнить произвольное количество запросов к состоянию, причем содержимое этих запросов, равно и их количество зависят от результатов предыдущих запросов;
* вычисление не имеет возможности записи в состояние системы, только чтения.

В листинге \ref{lst:statep-req} представлен тип запроса множества ключей из состояния `StateReq`. Как можно заметить, его конструкция практически идентична конструкциям типов `StateP` и `ChangeSet`, с отличием в том, что в качестве обертки значения используется тип `Const ()`, что в результате означает что значения хранится не будут и ассоциативный массив используется как множество ключей. 

\begin{code}[language=Haskell,label=lst:statep-req,caption={Запрос множества ключей из состояния}]
type StateReq (mw :: ((* -> *) -> u -> *)) (rs :: [u])
    = Rec (mw (Const ())) rs
\end{code}

Тип `StateAccess1`, представленный в листинге \ref{lst:dbaccess}, представляет из себя пару, первым элементом которой является запрос к состоянию, вторым -- функция, которая принимает результат исполнения запроса и возвращает функцию продолжения вычисления.
В некоторых случаях это может оказаться недостаточным, например если требуется запросить не
какой-то конкретный ключ, а все ключи, отвечающие какому-либо критерию.

В простейшем случае требуется поддержка итерации всех ключей части состояния, соответствующей некоторой компоненте, что и реализовано в типе `StateAccess`, который будет использован в дальнейшем. Для этого вводится тип `StateIter`, аналогичный `StateReq`, построенный на основе типа `FoldF res a` -- функции итерации по ключам типа `a`, возвращающей значение res. 
На основе `StateIter` вводится функтор доступа к состоянию `StateAccess`.

\begin{code}[language=Haskell,label=lst:dbaccess,caption={Функтор доступа к состоянию}]
newtype StateAccess1 res mw rs
    = StateAccess1 (StateReq mw rs, StateP mw rs -> res)


data FoldF a res = forall b. FoldF (b, a -> b -> b, b -> res)
newtype MFoldF res a = MFoldF { unMFoldF :: Maybe (FoldF a res) }

newtype StateIter (mw :: ((* -> *) -> u -> *)) (rs :: [u]) (res :: *)
    = StateIter { unStateIter :: Rec (mw (MFoldF res)) rs }

instance Functor (FoldF a) where (..)
instance RecAll' rs (WrappedM mw) => Functor (StateIter mw rs) where (..)

data StateAccess mw rs res
    = SQuery    (StateReq mw rs) (StateP mw rs -> res)
    | SIterator (StateIter mw rs res)
  deriving Functor

\end{code}

Функтор доступа к состоянию `StateAccess` позволяет либо однократно запросить произвольное множество ключей из состояние, либо однократно проитерироваться по всем ключам выбранных компонент состояния. Однако для многократного обращения к состоянию в качестве переменной типа `res` требуется подставить такой тип, который бы позволял повторить запрос неограниченное количество раз.

\image{state-comp-ex}{Пример исполнения вычисления с многократным доступом к состоянию}

\begin{code}[language=Haskell,label=lst:rocomp,caption={Тип вычисления, обращающегося к состоянию}]
class Monad m => Effectful eff m | m -> eff where
    parallel :: Semigroup a => m a -> m a -> m a
    effect :: eff a -> m a

newtype E eff a = E { unE :: forall m . Effectful eff m => m a }
  deriving Functor

instance Semigroup a => Semigroup (E eff a) where
    E a <> E b = E (parallel a b)

instance Applicative (E eff) where (..)
instance Monad (E eff) where (..)

type RoComp mw rs = E (StateAccess mw rs)
\end{code}

Существует несколько распространненных методов для моделирования такого вычисления в Haskell. Наиболее распространненным является моделирование вычислений с помощью классов типов, в частности используя стандартный класс `Monad`.
В листинге \ref{lst:rocomp} представлен тип `RoComp`. Как следует из его определение, вычисление обладающее типом `RoComp mw rs` (при наличие инстанса `WrappedM mw rs`) обладает следующими возможностями:

* последовательная композиция двух вычислений в случае когда одно вычисление зависит от результата предыдущего (возможность унаследована от класса `Monad`, метода `>>=`);
* параллельная композиция двух вычислений в случае когда вычисления не зависят от результата друг друга (метод `parallel`);
* чтение значений из состояния посредством запроса ключей или итерация по всем ключам состояния (метод `effect` вместе с предлставленым объектом функтора `StateAccess`).

Следует отметить, что параллельную композицию можно реализовать с помощью последовательной, используя метод `>>` класса `Monad`. Однако введение параллельной композиции как отдельного метода класса `Effectful` позволяет получить конструкцию с интересными свойствами, которые будут рассмотрены в следующем подразделе.

\subsection{Композиция вычислений в модели состояния}

\image{state-comp-ex}{Пример исполнения вычисления с многократным доступом к состоянию}
Пример исполнения вычисления, заданного типом `RoComp` представлен в 

\subsection{Валидация транзакции}

Важнейшей составляющей модели данных является валидация изменений, предлагаемых системе, или валидация транзакции. Задачей данного подраздела является введение 

Простейший валидатор транзакции может быть описан функцией, имеющей одну из сигнатур:

\begin{code}[language=Haskell]
validator1 :: StateTx id proof value -> Bool
validator1 = ...

validator2 :: StateP id value -> StateTx id proof value -> Bool
validator2 = ...

validator3 :: StateTx id proof value -> (Set id, StateP id value -> Bool)
validator3 = ...
\end{code}

Функция `validator1` принимает транзакцию и возвращает `True` тогда и только тогда когда транзакция является корректной. Однако, только для очень небольшого класса транзакций можно выразить валидатор, используя функцию с такой сигнатурой. Реализация практически любой функциональности криптовалюты требует доступа валидатора к состоянию.

Функция `validator2` принимает на вход глобальное состояние системы. Функция позволяет выразить класс транзакций, чьи валидаторы требуют только доступа к состоянию системы для проверки транзакции. Такой класс достаточно широк для построения модели криптовалюты, однако использование такой сигнатуры функции является препятствием для построения эффективной реализации.

В существующих на сегодняшний день системах состояние системы измеряется в гигабайтах данных, передавать состояние как единый объект, полностью загруженный в оперативную память компьютера, является неэффективным
расходом ресурсов. Функция `validator3` в отличие от `validator2` не передаёт глобальное состояние как единый объект, но позволяет запросить интересующие ключи из состояния и возвратить результат валидации транзакции в соответствии с возвращенными значениями.

Однако `validator3`, как и `validator1`, описывает только узкий класс транзакций, в общем смысле для валидации транзакции может потребоваться сделать более одного запроса к глобальному состоянию. Например, для проверки отсутствия циклов в цепочке делегаций, требуется выполнить как минимум `maxDlgHeight` запросов к базе, где `maxDlgHeight` -- максимальная путь в ациклическом графе делегации (параметр делегации).
Процесс валидации делегационной транзакции будет подробно рассмотрен в разделе \ref{ch02:delegation}.

Введем несколько вспомогательных типов, чтобы выразить тип валидатора, позволяющего выразить класс транзакций, имеющих возможность запроса ключей из состояния произвольное количество раз, допускающего эффективную реализацию.

\begin{code}[language=Haskell,label=lst:data-access,caption={Функтор обращения к состоянию}]
data FoldF a res = forall b. FoldF (b, a -> b -> b, b -> res)

data StateAccess id value res
  = DbQuery (Set (Prefixed id)) (StateP id value -> res)
  | DbIterator Prefix (FoldF (id, value) res)
  deriving (Functor)

type RoComp id value = Free (StateAccess id value)

validator4 :: StateTx id proof value -> RoComp id value Bool
validator4 = ..
\end{code}

Тип `StateAccess` представляет из себя тип-сумму, первый конструктор которого эквивалентен `StateAccess1`, второй представляет из себя интерфейс для итерации по множеству ключей. Тип `FoldF` представляет произвольную функцию свёртки: начальное значение `b`, свёртка по очередному элементу `a -> b -> b` и конверсия результата в тип результата `res`.

Тип `RoComp`, сигнатура функции `validator4` показывают, как подстановкой `StateAccess` как параметра в тип `Free` можно получить конструкцию, подходящую для описания валидатора. Сигнатура `validator4` позволяет реализации запрашивать ключи из глобального состояния, получать соответствующие им значения, причем
делать это столько раз, сколько потребуется.

Окончательный тип валидатора транзакции предложен в листинге \ref{lst:validator}:

\begin{code}[language=Haskell,label=lst:validator,caption={Тип валидатора транзакции}]
newtype PreValidator e id proof value =
  PreValidator 
    (StateTx id proof value -> ExceptT e (RoComp id value) ())

newtype Validator e id proof value =
  Validator (Map StateTxType (PreValidator e id proof value))
\end{code}

Тип `ExceptT e (RoComp id value) ()` является непосредственным обобщением типа `RoComp id value Bool`, позволяющим в случае если валидация транзакции закончилась отрицательным результатом, указать ошибку типа `e` (а не просто `False`). Тип `PreValidator` является достаточным для описания логики валидации, в частности при проверке транзакции, он может рассматривать тип транзакции (поле `txType`), возвращать положительный результат в случае если транзакция является корректной
и ошибку в случае если предложенный тип транзакции не предназначен для проверки данным валидатором или если транзакция является некорректной.

Однако, для проверки множества транзакций требуется различать, какой валидатор относится к первому типу транзакции, какой ко второму и т.д., т.к. ошибка, возвращенная валидатором при проверки транзакции, тип которой не соответствует типу, рассматриваемым валидатором, не обязательно указывает на некорректность транзакции. Потому в дополнению к типу `PreValidator` введён тип `Validator`, соддержащий в себе отображение из типа транзакции в соответствующий типу валидатор.

На логику проверки транзакции с помощью объекта типа `Validator` накладывается ограничение, что проверяемый тип транзакции содержится в хранящемся в объекте отображении, иначе возвращается ошибка. Это требуется для того, чтобы исключить возможность положительного результата валидации транзакции, чей тип неизвестен валидатору.

В последующем изложении под термином валидатор будет пониматься объект типа `Validator`, описанный типом выше, под термином предвалидатор -- объект типа `PreValidator`.

\subsection{Моноидальная структура валидатора}

Важным свойством определенных выше валидатора, предвалидатора является их моноидальная структура. Рассмотрим подробнее определения моноидальной единицы, моноидального умножения для этих двух типов.

Моноидальная единица для предвалидатора реализуется просто: это предвалидатор, разрешающий всякую транзакцию. Аналогично для валидатора: единицей является тип, запрещающий всякую транзакцию (пустой ассоциативный массив из типа транзакции в предвалидатор).

Умножение для валидатора представляет из себя объединение двух ассоциативных массивов из типа транзакции в предвалидатор, причем при совпадении ключей, требуется воспользоваться моноидальным умножением для предвалидатора.

Умножение для предвалидатора сводится к умножению двух вычислений типа `ExceptT e (RoComp id value) ()`. Или, эквивалентно, `RoComp id value (Either e ())`. Соответствующими типу значениями могут быть: `Free dbaccess`, `Pure (Left e)`, `Pure (Right ())`. Если одно из значений `Pure (Left e)`, вычисление завершается ошибкой `e`, т.е. результат умножения -- `Pure (Left e)`. Если один из операндов умножения `Pure (Right ())`, результат умножения равен другому операнду.

Наконец, если мы имеем операнды `Free dbaccess1`, `Free dbaccess2`, следует произвести следующее:

* Если `dbaccess1 = DBQuery idSet1 cont1`, `dbaccess2 = DBQuery idSet2 cont2`, результат умножения будет равен `DBQuery idSet3 cont3`, где $idSet3 = idSet1 \cup idSet2$, $cont3 = \lambda values . cont1 \: (values \cap idSet1) \cdot cont2 \: (values \cap idSet2)$ (обозначение $\cdot$ используется для моноидального умножения).
* Если `dbaccess1 = DBIterator p (FoldF (init, foldf, resF))`, результат умножения будет `DBIterator p (FoldF (init, foldf, resF'))`, где $resF' = \lambda b . \: (resF \: b) \cdot (Free \: dbaccess2)$
* Аналогично для `dbaccess2 = DBIterator p f2`

Определенное таким образом моноидальное умножение обладает интересным свойством: соседствующие операнды `DBQuery idSet cont` будут объединены в один. Это означает что множество небольших запросов к состоянию будут объединены в один композитный запрос (что представляет собой распространенную и достаточно эффективную оптимизацию при работе с базами данных).

В дальнейшем при построении модели мы будем активно пользоваться моноиальной структурой валидатора и предвалидатора. Эта особенность позволяет описывать различные функциональности независимо друг от друга (посредством описания соответствующих предвалидаторов, валидаторов), а затем совмещать их вместе, используя моноидальное умножение.

\subsection{Валидация структуры транзакции}

Для проверки структуры транзакции на корректность (безотносительно к типу транзакции) следует выолнять проверки свойств, описанных в формуле \ref{prop:bc_modify}. Выполнение этих проверок объединим в предвалидатор `structuralPrevalidator`, которым мы воспользуемся в дальнейшем построении модели.
