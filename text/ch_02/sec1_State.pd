\section{Модель локального состояния системы}

\label{ch02-state}

Как было замечено в разделе \ref{ch01:blockchain-applications}, большинство блокчейн-систем представляют из себя распределенные базы данных. Вследствие этого, для построения модели блокчейн-системы, следует начать с формализации состояния базы данных, способа его изменения.

\subsection{Тип состояния системы}

Тип `StateP1`, представленный в листинге \ref{lst:statep1}, выражает тип состояния системы -- как глобального состояния в целом, так и его части.
Состояние представляется как словарь -- отображение из ключа `key` в значение `value`.
И ключ, и значение введены как абстрактные типы. Это позволяет использовать определения для произвольных ключей и значений, применяя для разных типов одни и те же полиморфные функции.

\begin{code}[language=Haskell,label=lst:statep1,caption={Тип состояния системы $StateP1$}]
import           Data.Map (Map)

type StateP1 key value = Map key value -- Portion of state
\end{code}

Тип `StateP1` описывает состояние, в котором типы ключа и значения фиксированы и одинаковы для всех компонент одной системы. Это в принципе позволяет описать многокомпонентную систему, даже учитывая различия репрезентации данных в различных компонентах. В частности возможно задать типы ключа и значения как суммы частных типов конкретных компонент, как продемонстрировано в листинге \ref{lst:statep1-example}.
Следует также заметить, что функциям, работающими с данными каких-либо отдельных компонент системы, будет требоваться выбирать из хранилища ключи, созданные интересующим конструктором и проверить соответствие конструктора значения, потенциально завершая исполнение исключением.

\begin{code}[language=Haskell,label=lst:statep1-example,caption={Пример использования структуры состояния: тип-сумма}]
data Address = ..
data PublicKey = ..
data Signature = ..

data ExampleKey1 = EkDlg PublicKey | EkBalances Address

data ExampleValue1 = EvDlg (Address, Signature) | EvBalances Word32
\end{code}

Для написания функций, работающих с отдельными компонентами системы, было бы удобно разделять состояние системы на несколько частей, задавая типы для каждой из частей отдельно. Это можно сделать, представляя состояние как тип-произведение нескольких состояний `StateP1` (листинг \ref{lst:statep1-example2}). В частности для системы из двух компонент в виде пары.
Однако такое представление имеет существенный недостаток: требуется либо использовать конкретные типы, либо зависеть от числа компонент,
что затрудняет реализацию полиморфных функций, работающих с состоянием системы в целом, а не только отдельных компонент.

\begin{code}[language=Haskell,label=lst:statep1-example2,caption={Пример использования структуры состояния: тип-произведение}]
type StateP2 =
  ( StateP1 PublicKey (Address, Signature)
  , StateP1 Address Word32
  )

\end{code}

Кроме того, для формализации дополнения транзакций (раздел \ref{ch02-expand}) требуется указывать в типе информацию о том, данные каких именно компонент содержатся в объекте состояния. Для разрешения этих затруднений окончательный тип состояния системы `StateP` получился несколько более сложным и для его определения используется ряд продвинутых возможностей системы типов Haskell -- в частности семейства типов, поднятие типов до видов.

В определении типа `StateP`, представленном в листинге \ref{lst:statep}, используется тип `Rec` из библиотеки `Vinyl` (подраздел \ref{ch01-vinyl}). Он позволяет задать гетерогенный список хранилищ различных компонент. Тип `StateP` полагается на существование вида `u`.
Произвольный тип `r`, принадлежащий виду `u`, идентифицирует некую компоненту. Тип `mw` параметризуется типом `g`, в который оборачивается тип-значение, и типом `r`, возвращая тип хранилища для соответствующей `r` компоненте, причем возвращаемый тип изоморфен `Map k (g v)` для некоторых `k` и `v`, соответствующих `r`. Изоморфизм типу `Map k (g v)` задается экземпляром класса `WrappedM`.

\begin{code}[language=Haskell,label=lst:statep,caption={Тип состояния системы $StateP$}]
{-# LANGUAGE PolyKinds           #-}
{-# LANGUAGE TypeInType          #-}

import Data.Vynil
import Contol.Lens (iso, Iso')

type StateP (mw :: ((* -> *) -> u -> *)) (rs :: [u]) = Rec (mw Identity) rs

class (Show (K mw t)) =>
  WrappedM (mw :: ((* -> *) -> u -> *)) (t :: u) where
    type K mw t :: *
    type V mw t :: *
    wrappedM' :: forall (g :: * -> *) . Iso' (mw g t) (U g mw t)
    consA :: forall (g :: * -> *) . U g mw t -> mw g t

type U g mw t = Map (K mw t) (g (V mw t))

\end{code}


Для внесения большей ясности в природу типа `StateP` и его параметров, рассмотрим пример использования, представленный в листинге \ref{lst:statep-ex}. Тип данных `ExampleStorage` при включенном расширении `DataKinds` порождает вид `ExampleStorage` с двумя возможными типами: `ESDlg`, `ESBalances`. Семейство типов `EST` задает типы ключа и значения.
Тип `M` принимает тип-обертку значения `g :: *-> *` и тип-маркер компоненты `f :: ExampleStorage` и является оберткой над ассоциативным массивом,
представляющим состояние.
Соответствующий экземпляр класса `WrappedM` позволяет получить доступ к объекту типа `Map`.
Значение `exStateP` содержит объект состояния, в котором содержатся ключи компоненты `ESDlg`, в то время как `exStateP2` содержит ключи компонент `ESBalances`, `ESDlg`. Следует заметить, что вследствие того, что типы хранилищ задаются семейством типов `EST`, использование неподходящего типа значения приведет к ошибке компиляции.

\begin{code}[language=Haskell,label=lst:statep-ex,caption={Пример использования типа $StateP$}]
{-# LANGUAGE DataKinds           #-}

type family Fst a where Fst '(x,y) = x
type family Snd a where Snd '(x,y) = y

data ExampleStorage = ESBalances | ESDlg
  deriving Show

type family EST (f :: ExampleStorage) :: (*, *) where
  EST 'ESBalances = '(Int, Word16)
  EST 'ESDlg = '(Int, String)

newtype M g f = M { unM :: Map (Fst (EST f)) (g (Snd (EST f))) }

instance (Show (Fst (EST t))) => WrappedM M t where
    type K M t = Fst (EST t)
    type V M t = Snd (EST t)
    wrappedM' = iso unM M
    consA = M

exStateP :: StateP M '[ 'ESDlg]
exStateP = M (M.fromList [ (30, Identity "someValue") ]) :& RNil

exStateP2 :: StateP M '[ 'ESBalances, 'ESDlg]
exStateP2 =
  M (M.fromList [ (30, Identity 1005) ])
    :& M (M.fromList [ (30, Identity "someValue") ]) :& RNil

\end{code}

\subsection{Тип транзакции к состоянию}

Рассмотрим изменение конкретного ключа в состоянии. В листинге \ref{lst:valueop} представлен тип `ValueOp`, представляющий из себя объект-изменение ключа в состоянии. Тип `ValueOp` задает несколько конструкторов. Конструктор `New` создает новое значение, `Rem` -- удаляет существующее значение. Конструктор `Upd` обновляет существующее значение (возможно, возвращая ошибку), конструктор `NotExisted` является маркером того, что значения не существует -- тип `NotExisted` эквивалентен последовательному
применению `New x`, `Rem`. 
Следует заметить, что для типа `ValueOp` нельзя определить композицию, так как последовательное применение некоторых конструкторов приводит к ошибке (например, `Rem` и `Upd`). Поэтому задается тип `ValueOpEx`, для которого реализуется экземпляр `Semigroup`.

\begin{code}[language=Haskell,label=lst:valueop,caption={Изменение значения некоторого ключа}]
data ValueOp v
    = New v
    | Upd (v -> v)
    | Rem
    | NotExisted
    deriving (Show, Eq)

data ValueOpEx v
    = Op (ValueOp v)
    | Err
    deriving (Show, Eq)

instance Semigroup (ValueOpEx v) where
  (<>) a b = ...
\end{code}

В листинге \ref{lst:changeset} вводится тип изменения состояния. В объекте изменения состояния для каждой компоненты состояния определяется объект типа `Map k (ValueOp v)`, то есть для некоторого подмножества ключей состояния задается способ их изменения. Требуется заметить, что применение объекта изменений может завершиться ошибкой -- например, если ключу, отсутствующему в состоянии, сопоставлено изменение `Rem`.
В листинге \ref{lst:changeset} также представлен тип функции `chgsetMappend`, с помощью которой можно композировать последовательные изменения состояния.
Семейства типов `RecAll`, `RecAll'` используются для установления ограничения на тип для каждого $r \in rs$.

\begin{code}[language=Haskell,label=lst:changeset,caption={Изменение состояния системы}]
type ChangeSet (mw :: ((* -> *) -> u -> *)) (rs :: [u]) = Rec (mw ValueOp) rs

chgsetMappend
  :: forall rs mw .
     ( RecAll' rs (WrappedM mw)
     , Semigroup (Rec (mw ValueOpEx) rs)
     )
  => ChangeSet mw rs -> ChangeSet mw rs -> VerRes String (ChangeSet mw rs)
\end{code}


Транзакция к состоянию представлена в листинге \ref{lst:tx}.
Помимо изменения состояния, транзакция содержит в себе еще два поля: `txType` и `txProof`.
Поле `txType` представляет из себя целочисленный идентификатор типа транзакции.
Поле `txProof` содержит в себе дополнительную информацию, требующуюся валидатору для проверки корректности транзакции.
В частности, для транзакции, изменяющей баланс пользовательского счета, `txProof`, должен содержать подпись транзакции секретным ключом пользователя-владельца средств.
Поля `txType`, `txProof` будут впоследствии использованы при построении валидатора.
Что существенно, поле `txBody` содержит в себе полный набор изменений, которые будут применены к состоянию системы. Ни `txProof`, ни `txType` не будут применены к состоянию и будут забыты как только валидатор их обработает.

\begin{code}[language=Haskell,label=lst:tx,caption={Транзакция}]
newtype StateTxType = StateTxType Int

data StateTx mw rs proof = StateTx
    { txType  :: StateTxType
    , txProof :: proof
    , txBody  :: ChangeSet mw rs
    }
\end{code}

\subsection{Вычисление в модели состояния}

\begin{definition}{Вычисление в модели состояния}
 -- функция, выполняющая последовательность запросов к состоянию для возврата результата.
\end{definition}

Задачей настоящего подразадела является формулировка типа вычисления в модели состояния. При построении типа используются следующие соображения:

* вычисление может выполнить произвольное число запросов к состоянию, причем содержимое этих запросов, равно как и их число зависят от результатов предыдущих запросов;
* вычисление не имеет возможности записи в состояние системы, разрешено только чтение.

В листинге \ref{lst:statep-req} представлен тип запроса множества ключей из состояния `StateReq`. Как можно заметить, его конструкция практически идентична конструкциям типов `StateP` и `ChangeSet`, с отличием в том, что в качестве обертки значения используется тип `Const ()`, что в результате означает, что значения храниться не будут и ассоциативный массив используется как множество ключей. 

\begin{code}[language=Haskell,label=lst:statep-req,caption={Запрос множества ключей из состояния}]
type StateReq (mw :: ((* -> *) -> u -> *)) (rs :: [u])
    = Rec (mw (Const ())) rs
\end{code}

Тип `StateAccess1`, представленный в листинге \ref{lst:dbaccess}, представляет из себя пару, первым элементом которой является запрос к состоянию, вторым -- функция, которая принимает результат исполнения запроса и возвращает функцию продолжения вычисления.
В некоторых случаях это может оказаться недостаточным, например если требуется запросить не
какой-то конкретный ключ, а все ключи, отвечающие какому-либо критерию.

В простейшем случае требуется поддержка итерации всех ключей части состояния, соответствующей некоторой компоненте, что и реализовано в типе `StateAccess`, который будет использован в дальнейшем. Для этого вводится тип `StateIter`, аналогичный `StateReq`, построенный на основе типа `FoldF res a` -- функции итерации по ключам типа `a`, возвращающей значение res. 
На основе `StateIter` вводится функтор доступа к состоянию `StateAccess`.

\begin{code}[language=Haskell,label=lst:dbaccess,caption={Функтор доступа к состоянию}]
newtype StateAccess1 res mw rs
    = StateAccess1 (StateReq mw rs, StateP mw rs -> res)


data FoldF a res = forall b. FoldF (b, a -> b -> b, b -> res)
newtype MFoldF res a = MFoldF { unMFoldF :: Maybe (FoldF a res) }

newtype StateIter (mw :: ((* -> *) -> u -> *)) (rs :: [u]) (res :: *)
    = StateIter { unStateIter :: Rec (mw (MFoldF res)) rs }

instance Functor (FoldF a) where (..)
instance RecAll' rs (WrappedM mw) => Functor (StateIter mw rs) where (..)

data StateAccess mw rs res =
  StateAccess
    { sQuery    :: StateReq mw rs
    , sHandler  :: StateP mw rs -> res
    , sIterator :: StateIter mw rs res
    }
  deriving Functor

\end{code}

Функтор доступа к состоянию `StateAccess` позволяет либо однократно запросить произвольное множество ключей из состояния, либо однократно проитерироваться по всем ключам выбранных компонент состояния. Однако для многократного обращения к состоянию в качестве переменной типа `res` требуется подставить такой тип, который бы позволял повторить запрос неограниченное число раз.

\begin{property}{}
\label{prop:monoid-sa}
Функтор доступа к состоянию $StateAccess \; mw \;  rs$, примененный к типу с моноидальной структурой $res$, является моноидом.
\end{property}

Свойство \ref{prop:monoid-sa} показывается довольно просто, поскольку следует из моноидальной структуры типа `Rec`, и будет использовано в дальнейшем.

\image{state-comp-ex}{Пример исполнения вычисления с многократным доступом к состоянию}

\begin{code}[language=Haskell,label=lst:rocomp,caption={Тип вычисления, обращающегося к состоянию}]
class Monad m => Effectful eff m | m -> eff where
    parallel :: Semigroup a => m a -> m a -> m a
    effect :: eff a -> m a

newtype Eff eff a = Eff { unEff :: forall m . Effectful eff m => m a }
  deriving Functor

instance Semigroup a => Semigroup (Eff eff a) where
    Eff a <> Eff b = Eff (parallel a b)

instance Applicative (Eff eff) where (..)
instance Monad (Eff eff) where (..)

execEff :: eff a -> Eff a
execEff e = Eff (effect e)

type RoComp mw rs = Eff (StateAccess mw rs)
type ERoComp e mw rs = ExceptT e (RoComp mw rs)
\end{code}

Существует несколько распространненных методов для моделирования вычисления с многократным обращением к состоянию в Haskell. Наиболее распространненным является моделирование вычислений с помощью классов типов, в частности, используя стандартный класс `Monad`.
В листинге \ref{lst:rocomp} представлен тип `RoComp`. Как следует из его определения, вычисление, обладающее типом `RoComp mw rs` (при наличии экземпляра `WrappedM mw rs`), обладает следующими возможностями:

* последовательная композиция двух вычислений в случае, когда одно вычисление зависит от результата предыдущего (возможность унаследована от класса `Monad`, метода `>>=`);
* параллельная композиция двух вычислений в случае, когда вычисления не зависят от результата друг друга (метод `parallel` класса Effectful, доступный для типа `E` через оператор `<>`);
* чтение значений из состояния посредством запроса ключей или итерация по всем ключам состояния (метод `effect` вместе с представленым объектом функтора `StateAccess`).

Тип `ERoComp` представляет вычисление, которое к возможностям вычисления типа `RoComp` добавляет возврат ошибки исполнения в случае возникновения исключения. Возможность возврата ошибки требуется для выражения многих функциональностей.

Побочный эффект функции (англ. _side effect_) -- возможность в процессе выполнения своих вычислений: читать и модифицировать значения глобальных переменных, осуществлять операции ввода-вывода, реагировать на исключительные ситуации, вызывать их обработчики. Если вызвать функцию с побочным эффектом дважды с одним и тем же набором значений входных аргументов, может случиться так, что в качестве результата будут возвращены разные значения.
Важно отметить, что вычисление `RoComp` имеет только возможность чтения из состояния посредством функтора `StateAccess`, никакие другие побочные эффекты ему недоступны. В частности, вычисление `RoComp` не имеет доступа к:

* операциям с файловой системой;
* операциям с сетью;
* операциям с изменяемыми переменными (инстурументами синхронизации данных между потоками);
* операциям записи в состояние.

Такая ограниченность вычислений типа `RoComp` позволяет более четко рассуждать о произвольном вычислении такого типа, в том числе о его исполнении в отдельном потоке или композиции с другими вычислениями.

Следует отметить, что параллельную композицию можно реализовать с помощью последовательной, используя метод `>>` класса `Monad`. Однако введение параллельной композиции как отдельного метода класса `Effectful` позволяет получить конструкцию с интересными свойствами, которые будут рассмотрены в следующем подразделе.

\subsection{Композиция вычислений в модели состояния}

Рассмотрим следующую задачу: дано вычисление `comp :: a -> StateTx mw rs proof -> RoComp mw rs a`, требуется обобщить его на случай множества транзакций, то есть реализовать функцию `compMany :: a -> [StateTx mw rs proof] -> RoComp mw rs [a]`. Есть несколько особенностей, на которые следует обратить внимание при построении функции `compMany`:

* в случае, когда длина входного списка транзакций достаточно велика, а вычисление `comp` не является тривиальным, эффективная реализация `compMany` на многопроцессорной системе может требовать использования возможностей параллелизма, предоставляемых языком и системой;
* вычисление `comp`, примененное ко второй транзакции из списка, может ожидать в качестве первого параметра `a` как переданное изначально значение `a`, так и результат выполнения вычисления `comp` для первой транзакции.

Для того, чтобы упростить отслеживание зависимостей между частями вычисления `compMany`, а также понимание возможности многопоточного исполнения вычисления, при формулировании класса типов `Effectful` были созданы возможности для последовательной и параллельной композиции с помощью операторов `>>=` и `<>` соответственно.
С помощью выделения этих двух типов композиций для вычисления типа `RoComp`, применяемого к множеству входных данных, можно сформулировать одно важное свойство. Прежде чем перейти к формулировке свойства, введем понятие глубины вычисления.

\begin{definition}{Глубина вычисления в модели состояния}
\label{def:depth}
 -- число обращений к состоянию, которое сделает вычисление при некотором входе, максимизированное по всевозможным входам и минимизированное по всевозможным стратегиям запуска вычисления.
\end{definition}

Определение \ref{def:depth} можно также представить в виде уравнения:

\begin{equation} \label{def:depth-eq}
\begin{split}
& \textup{depth} \enspace (\enspace comp \in RoComp \enspace) \equiv
\\
&
\min_{Strategy}  \max_{Input} \; \{ \;
     \textup{CountStateAccess} (
        \textup{execute} \enspace ( Strategy, \; comp , \; Input )
      ) \; \}
\end{split}
\end{equation}

Наибольший интерес представляют две стратегии вычисления: 

* стратегия, при которой достигается минимум в формуле \ref{def:depth-eq};
* стратегия, при которой возможно наибольшее распараллеливание вычислений.

\begin{definition}{Стратегия с минимизацией запросов к состоянию}
\label{def:minreq-strategy}
 -- стратегия исполнения вычисления в модели состояния, при которой будет совершено минимальное число запросов к состоянию.
\end{definition}

Реализация стратегии из определения \ref{def:minreq-strategy} возможна благодаря свойству \ref{prop:monoid-sa} функтора доступа к состоянию о возможности объединения любых двух запросов в один. В частности, сформулируем стратегию $S_1$. Вычисление при использовании $S_1$ будет исполняться в один поток. Вычисление в модели состояния состоит из запросов к состоянию и использования последовательной и параллельной композиции. Следует заметить, что в случае последовательной композиции двух запросов
нет возможности объединить их в один запрос, так как последующий запрос непосредственно зависит от результата исполнения предыдущего.

Использование параллельной композиции двух вычислений позволяет оптимизировать число запросов к состоянию. В стратегии $S_1$ происходит объединение запросов двух вычислений $a$ и $b$, а именно: первые запросы из вычислений $a$ и $b$ будут объединены в один и исполнены, затем будет произведена последовательная композиция, в которую подставлен результат объединенного запроса, будут взяты вторые запросы, объединены, исполнены и т.д. 
Так как использование последовательной композиции к последовательным запросам неизбежно, полученная стратегия $S_1$ является стратегией с минимизацией запросов к состоянию.

\begin{definition}{Стратегия с максимизацией параллелизма}
\label{def:minreq-strategy}
 -- стратегия исполнения вычисления в модели состояния, при которой при каждом использовании параллельной композиции запускается отдельный поток вычисления.
\end{definition}

В примере на рисунке \ref{img:state-comp-composition} показывается использование обеих стратегий для запуска трех вычислений $A$, $B$, $C$, причем вычисление $B$ зависит от результата исполнения $A$. Таким образом композицию вычислений можно представить в виде формулы `(a >>= b)  <> c`. Каждое из трех вычислений на рисунке рассматривается как последовательность запросов, пронумерованная натуральными числами.

\image{state-comp-composition}{Две стратегии запуска трех вычислений}

\begin{definition}{Композиция фискированной глубины}
\label{def:minreq-strategy}
 -- композиция произвольного числа вычислений в модели состояния, глубина которой не зависит от числа вычислений, входящих в композицию.
\end{definition}

\begin{lemma}
\label{const-depth-lemma}
Композицию $N$ вычислений фиксированной глубины, каждое из которых делает фиксированное число запросов к состоянию, возможно выполнить в $O(N)$ потоков, каждый из которых сделает фиксированное число запросов к состоянию.
\end{lemma}

Доказательство:
Воспользуемся стратегией с максимизацией параллелизма.
Из фиксированной глубины композиции следует, что максимальная длина цепочки последовательных композиций также фиксирована.
Поскольку каждое из $N$ вычислений сделает фиксированное число запросов к состоянию, в цепи последовательных композиций фиксированное число элементов, каждый запущенный поток также совершит фиксированное число запросов к состоянию.
Новый поток будет запускаться при каждом использовании параллельной композиции, каждое из $N$ вычислений может содержать внутри использования параллельной композиции, однако не более фиксированного числа. Соответственно, будет запущено не более $O(N)$ потоков.
$\square$

Лемма \ref{const-depth-lemma} является ключом к эффективной с точки зрения использования возможностей параллелизма реализации блокчейн-систем. Системы, разработанные на сегодняшний день, обрабатывают последовательность блоков и транзакций последовательно, применяя следующую транзакцию только после применения предыдущей. 
В работах \emph{<<Adding concurrency to smart contracts>>} \citep{concurrent-contracts-speculative}, \emph{<<A concurrent perspective on smart contracts>>} \citep{concurrent-contracts} показывается возможность спекулятивного исполнения множества транзакций в нескольких параллельных потоков. Рассуждение представлено в контексте модели транзакций, предлагаемой системой Ethereum \citep{eth-web}. Однако с использованием леммы \ref{const-depth-lemma} можно достичь любой степени параллелизма без использования предположений о взаимосвязях между транзакциями, как это делается при реализации стратегий спекулятивного исполнения.

\subsection{Валидация транзакции}

Простейший валидатор транзакции может быть описан функцией, имеющей одну из сигнатур, представленных в листинге \ref{lst:validators-ex}.

\begin{code}[language=Haskell,label=lst:validators-ex,caption={Примеры сигнатур валидатора}]
validator1 :: StateTx mw rs proof -> Bool
validator1 = ...

validator2 :: StateP mw rs -> StateTx mw rs proof -> Bool
validator2 = ...

validator3 :: StateTx mw rs proof -> (StateReq mw rs, StateP mw rs -> Bool)
validator3 = ...

validator4 :: StateTx mw rs proof -> RoComp id value Bool
validator4 = ..
\end{code}

Функция `validator1` принимает транзакцию и возвращает `True` тогда и только тогда, когда транзакция является корректной. Однако только для очень небольшого класса транзакций можно выразить валидатор, используя функцию с такой сигнатурой. Реализация практически любой функциональности криптовалюты требует доступа валидатора к состоянию.

Функция `validator2` принимает на вход глобальное состояние системы. Функция позволяет выразить класс транзакций, чьи валидаторы требуют только доступа к состоянию системы для проверки транзакции. Такой класс достаточно широк для построения модели криптовалюты, однако использование такой сигнатуры функции является препятствием для построения эффективной реализации.

В существующих на сегодняшний день системах состояние системы измеряется в гигабайтах данных, поэтому передавать состояние как единый объект, полностью загруженный в оперативную память компьютера, является неэффективным
расходом ресурсов. Функция `validator3`, в отличие от `validator2`, не передает глобальное состояние как единый объект, но позволяет запросить интересующие ключи из состояния и вернуть результат валидации транзакции в соответствии с полученными значениями.

Однако `validator3`, как и `validator1`, описывает только узкий класс транзакций, поэтому в общем смысле для валидации транзакции может потребоваться сделать более одного запроса к глобальному состоянию. Например, для проверки отсутствия циклов в цепочке делегаций требуется выполнить как минимум `maxDlgHeight` запросов к базе, где `maxDlgHeight` -- максимальная длина пути в ациклическом графе делегации.
Процесс валидации делегационной транзакции будет подробно рассмотрен в разделе \ref{ch03-delegation}.
Окончательный тип валидатора транзакции предложен в листинге \ref{lst:validator}.

\begin{code}[language=Haskell,label=lst:validator,caption={Тип валидатора транзакции}]
newtype PreValidator e mw rs proof =
  PreValidator 
    (StateTx mw rs proof -> ERoComp e mw rs ())

newtype Validator e mw rs proof =
  Validator (Map StateTxType (PreValidator e mw rs proof))
\end{code}

Тип `PreValidator` является достаточным для описания логики валидации, в частности при проверки транзакции, он может рассматривать тип транзакции (поле `txType`), возвращать положительный результат в случае, если транзакция является корректной
и ошибку в случае, если предложенный тип транзакции не предназначен для проверки данным валидатором или если транзакция является некорректной.

Однако, для проверки множества транзакций требуется различать, какой валидатор относится к первому типу транзакции, какой ко второму и т.д., так как ошибка, возвращенная валидатором при проверки транзакции, тип которой не соответствует типу, рассматриваемым валидатором, не обязательно указывает на некорректность транзакции. Потому в дополнение к типу `PreValidator` введен тип `Validator`, содержащий в себе отображение из типа транзакции в соответствующий типу валидатор.

На логику проверки транзакции с помощью объекта типа `Validator` накладывается ограничение, что проверяемый тип транзакции содержится в хранящемся в объекте отображении, иначе возвращается ошибка. Это требуется для того, чтобы исключить возможность положительного результата валидации транзакции, чей тип неизвестен валидатору.
В последующем изложении под термином валидатор будет пониматься объект типа `Validator`, описанный типом выше, под термином предвалидатор -- объект типа `PreValidator`.
