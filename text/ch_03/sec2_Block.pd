\section{Модель блокчейна}

Данный раздел посвящен понятию блока. В отличие от большинства попыток формализовать модель блокчейн-системы, настоящая модель оперирует в первую очередь с состоянием системы и его изменением. Блок вводится как сущность, позволяющая описать:

* Цепь последовательных изменений
* Функцию выбора между двумя произвольными цепями изменений
* Ассоциацию множества последовательных изменений, которые требуется применить атомарно
    * Требуется для реализации многих алгоритмов консенсуса, в частности алгоритмов на основе методов доказательства доли владения, доказательства выполнения работы.

Рассмотрим тип блока:

\begin{code}[language=Haskell,label=lst:block,caption={Структура блока}]
data Block header payload = Block
    { blkHeader  :: header
    , blkPayload :: payload
    }
\end{code}

Блок включает в себя заголовок с абстрактным типом `header` и набор изменений состояния с абстрактным типом `payload` (в дальнейшем "тело блока").

\begin{code}[language=Haskell,label=lst:block-conf,caption={Конфигурация валидации цепи блоков}]
data BlkConfiguration header payload blockRef = BlkConfiguration
    { bcBlockRef     :: header -> blockRef
    , bcPrevBlockRef :: header -> Maybe blockRef
    , bcBlkIntegrityVerify    :: Block header payload -> Bool
    , bcIsBetterThan :: OldestFirst [] header -> OldestFirst [] header -> Bool
    , bcMaxForkDepth :: Int
    }
\end{code}

Что важно, для построения функциональности процессинга блоков нам не требуется информация о конкретном виде состояния, транзакции (описанные в разделе \ref{ch03-state}).
Логика валидации цепи блоков, конфигурация которой представлена в листинге \ref{lst:block-conf}, не требует доступа к состоянию системы.

Функция `bcBlockRef` позволяет получить уникальный идентификатор блока `blockRef`, как правило для его получения используется криптографически стойкая хэш-функция, применяемая к блоку. Функция `bcPrevBlockRef` позволяет получить идентификатор блока, предшествующего данному в цепи.

Функция `bcBlkIntegrityVerify` позволяет описать функцию, проверяющую целостность блока, в частности:

* Ассоциацию между заголовком и телом блока
* Ассоциацию между последовательными транзакциями в блоке
   * Полезно для описания взаимосвязи между различными транзакциями внутри блока. Пример взаимосвязи: всякая транзакия, переводящая средства с одного счёта на другой имеет в блоке соответствующую транзакцию, переводящую системе комиссия за выполненую операцию.

Функция `bcIsBetterThan` позволяет описать функцию выбора между двумя цепями изменений. Примером такой функции выбора является правило выбора цепочки с большей сложностью в Bitcoin.

Форком называется цепь, альтернативная принятой системой на текущий момент. Для любых двух цепей можно найти наименьшего общего предка $lca$ (который в случае, если цепи не содержат ни одного совпадающего блока будет равен `Nothing`). Глубиной форка называют глубину общего предка $lca$, т.е. количество переходов, сделанных с помощью функции `bcPrevBlockRef`, начав с голоыного блока цепи, требующихся чтобы получить идентификатор $lca$.

Параметр `bcMaxForkDepth` позволяет лимитировать глубину форка. Любой форк, глубина которого превышает `bcMaxForkDepth`, рассматривается как некорректный. Подобная проверка необходима для валидации некоторых консенсус-алгоритмов, в частности требуется алгоритмом Ouroboros \citep{ouroboros}.

С помощью описанной конфигурации, логика валидации цепи блоков может принять решение о том, следует ли предпочесть принятую на текущий момент цепь блоков $c1$ предложенной цепи $c2$. Для принятия решения логике валидации помимо конфигурации требуется перед сами цепочки $c1$, $c2$.

Помимо валидации цепи блоков, логика обработки блоков включает себя логику применения блоков к текущему состоянию сети. С точки зрения обработки блоков, состояние системы состоит из эффективного состояния системы `state` и хранилища блоков. Взаимодействие с состоянием системы описано конфигурацией
Хранилище блоков используется только логикой обработки блоков, изменеие

\begin{code}[language=Haskell,label=lst:block-state,caption={Конфигурация примемения блоков к состоянию}]
data BlkStateFunc header payload undo blockRef e m = BlkStateFunc
    { bsfApplyPayload :: payload -> ExceptT e m undo
    , bsfApplyUndo    :: undo    -> ExceptT e m ()
    , bsfStoreBlund   :: BlockWithUndo header payload undo -> m ()
    , bsfGetBlund     :: blockRef -> ExceptT e m (Maybe (BlockWithUndo header payload undo))
    , bsfBlockExists  :: blockRef -> m Bool
    , bsfGetTip       :: ExceptT e m blockRef
    , bsfSetTip       :: blockRef -> m ()
    , bsfConfig       :: BlkConfiguration header payload blockRef
    }
\end{code}

Для логики обработки блоков важно лишь знать что существует некоторое состояние `state`, к которому применяется `payload`. Заголовок `blkHeader`
используется только логикой обработки блоков.
