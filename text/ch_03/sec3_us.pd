\section{Система обновления}

Функционал обновления системы объединяет в себе набор механизмов, использующихся системой для:

* извещения пользователей о доступных обновлениях ПО;
* обновления протоколов системы, в т.ч. алгоритма консенсуса и его параметров;

Во всякой современной блокччейн-системе предусмотрена поддержка обновления ПО и протокола. Во многих блокчейн-системах поддержка обновления системы сводится к версионированию блоков (т.о. при обновлении версии блока клиент знает о необходимости обновления локальной версии ПО), в других же системах, например в Bitcoin \citep{btc-web}, существует ряд встроенных механизмов, позволяющих проводить ряд модификаций протокола с поддержкой совместимости с ранними версиями ПО.
Ни одна из существующих систем не рализует систему согласования обновления протокола или ПО между участниками сети.

\begin{definition}{Софт-форк}
 -- обновление протокола, поддерживающее совместимость с существующими версиями ПО.
\end{definition}

\begin{definition}{Хард-форк}
 -- обновление протокола, требующее обновления ПО большинством участников сети для дальнейшего функционирования сети.
\end{definition}

Под обновлением ПО мы понимаем обновление системы, не требующее обновление протокола (то есть обновление только ПО, используемого узлами сети).

Поддержка хард-форков является интереснейшей и важной задачей: реализация посредством софт-форков возможно только для ограниченного спектра обновлений протокола, до той степени, до которой создатели оригинального протокола предусмотрели эту возможность. В широко использующейся системе необходимость проведения хард-форка рано или поздно себя проявит, как следствие поддержка их важна.
В настоящей работе поддержка хард-форков не будет рассмотрена подробно, однако ее можно реализовать, используя идеи, схожие с теми что будут сформулированы в настощем разделе по отношению к софт-форкам, с применением механизма боковых цепей (англ. side chains \citep{sidechains}).
Основной сложностью в моделировании и проведении хард-форка притом является недопущение возможного разделения сети на две и более несвязных сегментов.

\subsection{Дизайн системы с поддержкой софт-форков}

Возможность выражения обновления протокола как софт-форка опирается на закладывание в построенную систему возможности расширения ее функциональности без изменения используемых протоколов (это касается протоколов взаимодействия по сети, сериализации, реализации алгоритма консенсуса и т.д.).
Основными двумя механизмами, которые можно использовать в дизайне протоколов системы, которые позволяют оставить пространство для расширения функционала в будущем, являются:

* параметризация протоколов;
* использование версионируемых структур данных.

Под параметризацией протоколов понимается вынесение важных параметров работы системы в некоторую объединенную конфигурацию, которую затем можно без особых усилий обновлять.
Многие параметры, от которых зависит протокол сети, можно вынести в такую конфигурацию: размер блока (дебаты из-за увеличения размера блока в сети Bitcoin не утихали многие месяцы, что в итоге привело к разделению сети на два сегмента), формула вычисления комиссии за транзакцию, временная задержка выпуска блоков и т.д.
Вынесение их в конфигурацию на этапе дизайна системы значительно облегчает задачу обновления системы в будущем.

Конфигурация с параметрами системы может быть сделана частью объекта обновления системы, и в случае если обновление будет принято большинством участников сети, все участники сети смогут использовать обновленную версию протокола без обновления ПО (в случае, если новая версия протокола содержит исключительно обновление конфигурации параметров).

Использование версионируемых структур данных само по себе немногим помогает в реализации софт-форков. Однако идею версионирования данных можно развить соответствующим образом. Предположим есть клиент $c$, использующий устаревшую версию протокола, в котором поддерживались типы адреса $A1$, $A2$, но отсутствовала поддержка типа адреса $A3$. Предположим клиенту $c$ приходит блок новой версии, содержащий транзакции, которые работают с адресом $A3$. 

Очевидно, полную валидацию транзакций (особенно в случае списания средств с адреса типа $A3$) клиент $c$ выполнить не может. Клиент $c$ по-прежнему может провалидировать остальные транзакции в блоке, также он может соответствующим образом изменить записи о балансах в предположении что транзакция типа $A3$ верна.
Предположение о верности $A3$ может быть ложным, однако если в дальнейшем большинством участников системы транзакция будет подтверждена и если системой гарантируется что большинство участников системы используют последнюю версию протокола, это предположение является корректным. В противном случае, если блок с транзакцией типа $A3$ будет в дальнейшем отклонен большинством участников сети, клиент $c$ может откатить блок с невалидной транзакцией.

\subsection{Механизм проведения софт-форков}

Опишем механизм обновления, сформулированный в системе, основанной на алгоритме консенсуса, использующего метод доказательства доли владения.

\begin{definition}{Объект обновления}
 -- объект данных, однозначно описывающий обновление системы.
\end{definition}

Объект обновления системы должен включать в себя:

* обновленную конфигурацию параметров системы;
* хэши бинарных объектов новой версии ПО;
* обновленный список версий версионируемых структур данных;
* версию протокола;

Версию протокола предлагается обозначать тройкой чисел $(Maj, \; Min, \; Alt)$. Значение $Maj$ обновлется только в случае обновления протокола типа хард-форк. Значение $Min$ обновляется при обновлении протокола типа софт-форк. Значение $Alt$ служит для различения конкурирующих обновлений системы.

Объект обновления публикуется для участников системы, после чего происходит голосование. Голоса участников взвешиваются в соответствии с их долей владения (для этого следует использовать метод `scGetStake` конфигурации обобщенного функционала метода доказательства доли владения). Каждый участник может проголосовать «за» или «против» обновления.

В случае, если в какой-то момент $\; > \; 50 \%$ участников проголосуют «за» или «против» обновления, обновление перейдет в статус подтвержденного, либо отклоненного.

Возможные изменения статуса обновления показаны в диаграмме \ref{img:us-proposal-states}.

\image{us-proposal-states}{Изменения статуса обновления протокола}

После подтверждения обновления большинством участников сети и стабилизации блока с последним имеющим значение голосом, версия протокола принимает статус соревнующейся. Она станет примененной только в тот момент, когда подавляющее число владельцев доли (параметр задается произвольно, но на практике следует использовать параметр не менее $80\%$) обновит версию ПО и выпустит блок, подтверждающий факт обновления ПО до версии, поддерживающей новую версию протокола.

\image{us-bv-states}{Изменения статуса версии протокола}

\subsection{Реализация механизма проведения софт-форков}

Для эффективной реализации механизма проведения софт-форков требуется определить период времени, по прошествии которого будет производиться итерация по всем голосам, соответствующим каждому из активных обновлений, подсчитывать суммарную долю владения всех участников, проголосовавших «за» или «против» и в случае если количество голосов достаточное, перевести обновление в статус подтвержденного, а версии протокола -- в статус конкурирующей.

Описанные действия не представляет труда описать в рамках предлагаемой модели с использованием конфигурации обобщенного функционала метода делегации доли владения с использованием модели состояния и модели обработки блоков.
