\section{Обобщенный функционал метода доказательства доли владения}

Блокчейн-система, использующая метод доказательства доли владения, обладает следующими характеристиками:

* система хранит информацию о долях владения;
* всякий блок сопровожден подписью его создателя;
* право создания блока определяется по идентификатору создателя, текущему времени и, возможно, некоему объекту доказательства, хранящемуся в одной из транзакций блока.

На основании этих наблюдений можно сформулировать обобщенный функционал метода делегации доли владения.
В листинге \ref{lst:pos-conf} представлена конфигурация обобщенного функционала `StakeConfiguration`.
Метод `scGetStake` позволяет получить значение доли владения некоторого участника. Этот метод будет в дальнейшем использован для построения функциональностей, использующих информацию о долях владения.
Метод `scEligibleToForge` позволяет по идентификатору создателя блока `stId` и некоторому объекту доказательства `proof`, проверить что `stId` имел право выпустить блок при текущем состоянии
системы (метод `scEligibleToForge` завершится ошибкой в случае, если правом создания блока `stId` не обладает).

\begin{code}[language=Haskell,label=lst:pos-conf,caption={Конфигурация обобщенного функционала PoS}]
data StakeConfiguration e mw rs proof stId = StakeConfiguration
    { scGetStake        :: stId -> ERoComp e mw rs (Ratio Int)
    , scEligibleToForge :: stId -> proof -> ERoComp e mw rs ()
    }
\end{code}

Реализация обобщенного функционала метода делегации доли владения состоит из двух составляющих:

  * объект `BlockIntegrityVerifier`, проверящий что первая транзакция блока имеет специальный тип `blockStart`;
  * валидатор для транзакции типа `blockStart`, проверяющий, что участник системы, чья подпись блока хранится в транзакции, имеет право выпуска блока при текущем состоянии системы.

Для реализации валидатора следует использовать метод `scEligibleToForge` конфигурации, который полностью энкапсулирует всю информацию, предоставляемую алгоритмом консенсуса.
Следует особенно отметить, что с использованием конфигурации из листинга \ref{lst:pos-conf}, реализации валидатора и объекта `BlockIntegrityVerifier` получатся обобщенными, то есть подходящими для использования с любыми алгоритмами консенсуса, предоставляющими конфигурацию. 
Тип конфигурации же является достаточно абстрактной, чтобы его можно было удовлетворить, используя любой из алгоритмов, использующих метод доказательства доли владения.

\subsection{Реализация алгоритма Ouroboros}

К сожалению, полное рассмотрение реализации протокола Ouroboros выходит за рамки настоящей работы. Следует отметить, что показать возможность реализации алгоритма поверх предложенной модели блокчейн-системы и обобщенного функционала метода PoS не представляет трудности. Хочется отметить несколько особенностей реализации.

В алгоритме Ouroboros время разбито на эпохи, каждая эпоха -- $10k$ слотов, каждый слот -- $S$ секунд. В сухом остатке это означает необходимость функционала протокла доступа к текущему времени ОС, что допускается механимом доступа к параметрам ОС.

Для каждого слота определен лидер, более того для эпохи в целом известен список $L$ последовательных лидеров для соотвествующих слотов. Этот список удобно хранить в переменных состояния. Что интересно, реализация конфигурации обобщенного функционала метода PoS является в случае алгоритма Ouroboros достаточно простой: `eligibleToForge stId slot = toSlot currentTime == slot && L[slot] == stId`.

В алгоритме Ouroboros разрешается замена блоков глубины до $k$, этот параметр непосредственно соотносится с параметром `maxForkDepth` в конфигурации обработки блоков.

Изменения долей владения участников и многошаговый алгоритм генерации случайного числа легко реализовать в терминах модели состояния (посредством изменений соответствующим участникам ключей в состоянии). Генерация списка лидеров новой эпохи также не представляет трудности с использованием возможности итерации по ключам состояния, определенной в функторе доступа к состоянию.
