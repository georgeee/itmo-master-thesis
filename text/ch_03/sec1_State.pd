\section{Модель состояния системы}

Как было замечено в разделе \ref{ch01:blockchain-applications}, большинство блокчейн-систем представляют из себя распределенные базы данных. В следствии этого, для построения модели блокчейн-системы, следует начать с формализации состояния базы данных, способа его изменять.

\begin{code}[language=Haskell,label=lst:statep,caption={Структура состояния системы}]
import qualified Data.Map as M
import           Data.Map (Map)

newtype Prefix = Prefix Int
type Prefixed k = (Prefix, k)

type StateP id value = Map (Prefixed id) value -- Portion of state
\end{code}

Тип `StateP` выражает тип состояния системы. Причем как глобального состояния целиком, так и его части.
Состояние представляется как словарь, отображение из ключа `(Int, id)` в значение `value`. Целочисленный префикс ключа введен для удобства дальнейшего построения.

И ключ, и префикс введены как абстрактные типы. Это означает, что для описания модели нам не требуется указывать, какой именно тип имеет ключ или значение. При описании работы с состоянием (в дальнейшем), будут накладываться различные ограничения (требования) на ключ или значение. Для выражения ограничений в нотации будет использоваться конструкция языка Haskell тайп-класс, например:

\begin{code}[language=Haskell,label=lst:constraints-example,caption={Пример наложения ограничений на абстрактные переменные}]
getMonoidValue :: (Ord id, Monoid value) => Prefixed id -> StateP id value -> value
getMonoidValue key stateP = maybe mempty (M.lookup key stateP)
\end{code}

В примере было наложено ограничение `Ord id` на ключ, выражающее требование существования линейного порядка на множестве всех ключей. В сигнатуре функции указано еще одно требование, `Monoid value`, требующее от `value` моноидальную структуру.

\subsection{Вид транзакции}

В листинге \ref{lst:changeset} формализовано изменение состояния.
Изменение словаря можно представить как тип-произведение из множества ключей,
которые требуется удалить `csRemove` и множества пар ключ-значение, которые требуется добавить в словарь `csAdd`.

\begin{code}[language=Haskell,label=lst:changeset,caption={Изменение состояния системы}]
data ChangeSet id value = ChangeSet
    { csAdd    :: Map (Prefixed id) value
    , csRemove :: Set (Prefixed id)
    }
\end{code}

Применение объекта типа `ChangeSet id value` к словарю должно иметь следующую семантику:

\begin{equation} \label{prop:bc_modify}
\begin{split}
& applyChangeSet\: (\: state : StateP, \: \langle csAdd, csRemove \rangle : ChangeSet \:) \enspace = \enspace
\\
& \quad 
     \begin{cases}
       \bot, \quad \text {if }
       \\ \quad\quad csRemove \cap keys(state) \neq csRemove 
       \\ \quad\quad\quad\quad \lor (keys(csAdd) \setminus csRemove) \cap keys(state) \neq \emptyset
       \\
       (state \setminus csRemove) \cap csAdd, \quad \text {otherwise}
    \end{cases} 
\end{split}
\end{equation}

Транзакция к состоянию имеет следующий вид:

\begin{code}[language=Haskell,label=lst:tx,caption={Транзакция}]
newtype TxType = TxType Int

data Tx id proof value = Tx
    { txType  :: TxType
    , txProof :: proof
    , txBody  :: ChangeSet id value
    }
\end{code}

Помимо изменения состояния, транзакция содердит в себе еще два поля: `txType` и `txProof`.
Поле `txType` представляет из себя целочисленный идентификатор типа транзакции.
Поле `txProof` содержит в себе дополнительную информацию, требующуюся валидатору для проверки корректности транзакции.
В частности, для транзакции, изменяющей баланс пользовательского счёта, `txProof`, должен содержать подпись транзакции секретным ключом пользователя-владельца средств.

Оба поля будут использованы в последствии в построении валидатора.
Что существенно, поле `txBody` содержит в себе полный набор изменений, которые будут применены к состоянию системы. Ни `txProof`, ни `txType` не будут применены к состоянию, будут забыты как только валидатор их обработает.

\subsection{Валидация транзакции}

Простейший валидатор транзакции может быть описан функцией, имеющей одну из сигнатур:

\begin{code}[language=Haskell]
validator1 :: Tx id proof value -> Bool
validator1 = ...

validator2 :: StateP id value -> Tx id proof value -> Bool
validator2 = ...

validator3 :: Tx id proof value -> (Set id, StateP id value -> Bool)
validator3 = ...
\end{code}

Функция `validator1` принимает транзакцию и возвращает `True` тогда и только тогда когда транзакция является корректной. Однако, только для очень небольшого класса транзакций можно выразить валидатор, используя функцию с такой сигнатурой. Реализация практически любой функциональности криптовалюты требует доступа валидатора к состоянию.

Функция `validator2` принимает на вход глобальное состояние системы. Функция позволяет выразить класс транзакций, чьи валидаторы требуют только доступа к состоянию системы для проверки транзакции. Такой класс достаточно широк для построения модели криптовалюты, однако использование такой сигнатуры функции является препятствием для построения эффективной реализации.

В существующих на сегодняшний день системах состояние системы измеряется в гигабайтах данных, передавать состояние как единый объект, полностью загруженный в оперативную память компьютера, является неэффективным
расходом ресурсов. Функция `validator3` в отличие от `validator2` не передаёт глобальное состояние как единый объект, но позволяет запросить интересующие ключи из состояния и возвратить результат валидации транзакции в соответствии с возвращенными значениями.

Однако `validator3`, как и `validator1`, описывает только узкий класс транзакций, в общем смысле для валидации транзакции может потребоваться сделать более одного запроса к глобальному состоянию. Например, для проверки отсутствия циклов в цепочке делегаций, требуется выполнить как минимум `maxDlgHeight` запросов к базе, где `maxDlgHeight` -- максимальная путь в ациклическом графе делегации (параметр делегации).
Процесс валидации делегационной транзакции будет подробно рассмотрен в разделе \ref{ch03:delegation}.

Введем несколько вспомогательных типов, чтобы выразить тип валидатора, позволяющего выразить класс транзакций, имеющих возможность запроса ключей из состояния произвольное количество раз, допускающего эффективную реализацию.
Воспользуемся концепцией свободной монады, определенной в языке Haskell (подробнее с концепцией свободных монад можно ознакомиться в документации к библиотеке free \citep{free-hackage}). Свободная монада определяется следующим типом данных:

\begin{code}[language=Haskell,label=lst:free-monad,caption={Свободная монада}]
data Free f a
  = Pure a
  | Free (f (Free f a))
\end{code}

Тип данных `Free` описывает чистую функцию, которая возвращает либо значение, либо запрос к внешнему контексту.
Тип `Free` определяет два конструктора: `Pure` и `Free`.
Конструктор `Pure` используется для возврата значения, конструктор `Free` для обращения к внешнему контексту с последующим продолжением вычисления.
Переменная типа `f` задаёт конкретный формат обращения к внешнему контексту и обработки результата обращения.

\begin{code}[language=Haskell,label=lst:reqiter,caption={Функтор обращения к состоянию}]
newtype ReqIter req resp res = ReqIter (req, resp -> res)
  deriving (Monoid, Functor)

type StateComputation req resp = Free (ReqIter req resp)
type StatePComputation id value = StateComputation (Set id) (StateP id value)

validator4 :: Tx id proof value -> StatePComputation id value Bool
validator4 = ..
\end{code}

Тип `ReqIter` представляет из себя пару, первым элементом которой является запросом к состоянию, вторым -- функция, которая принимает результат исполнения запроса и возвращает функцию продолжения вычисления. Тип `StatePComputation`, сигнатура функции `validator4` показывают, как подстановкой `ReqIter` как параметра в тип `Free` можно получить конструкцию, подходящую для описания валидатора. Сигнатура `validator4` позволяет реализации запрашивать ключи из глобального состояния, получать соответствующие им значения, причем
делать это столько раз, сколько потребуется.

Окончательный тип валидатора транзакции предложен в листинге \ref{lst:validator}:

\begin{code}[language=Haskell,label=lst:validator,caption={Тип валидатора транзакции}]
newtype PreValidator e id proof value =
  PreValidator (Tx id proof value -> ExceptT e (StatePComputation id value) ())

newtype Validator e id proof value =
  Validator (Map TxType (PreValidator e id proof value))
\end{code}

Тип `ExceptT e (StatePComputation id value) ()` является непосредственным обобщением типа `StatePComputation id value Bool`, позволяющим в случае если валидация транзакции закончилась отрицательным результатом, указать ошибку типа `e` (а не просто `False`). Тип `PreValidator` является достаточным для описания логики валидации, в частности при проверке транзакции, он может рассматривать тип транзакции (поле `txType`), возвращать положительный результат в случае если транзакция является корректной
и ошибку в случае если предложенный тип транзакции не предназначен для проверки данным валидатором или если транзакция является некорректной.

Однако, для проверки множества транзакций требуется различать, какой валидатор относится к первому типу транзакции, какой ко второму и т.д., т.к. ошибка, возвращенная валидатором при проверки транзакции, тип которой не соответствует типу, рассматриваемым валидатором, не обязательно указывает на некорректность транзакции. Потому в дополнению к типу `PreValidator` введён тип `Validator`, соддержащий в себе отображение из типа транзакции в соответствующий типу валидатор.

На логику проверки транзакции с помощью объекта типа `Validator` накладывается ограничение, что проверяемый тип транзакции содержится в хранящемся в объекте отображении, иначе возвращается ошибка. Это требуется для того, чтобы исключить возможность положительного результата валидации транзакции, чей тип неизвестен валидатору.

В последующем изложении под термином валидатор будет пониматься объект типа `Validator`, описанный типом выше, под термином предвалидатор -- объект типа `PreValidator`.

\subsection{Моноидальная структура валидатора}

Важным свойством определенных выше валидатора, предвалидатора является их моноидальная структура. Рассмотрим подробнее определения моноидальной единицы, моноидального умножения.

TODO моноидальная структура валидатора
