\section{Модель состояния системы}

\label{ch03-state}

Как было замечено в разделе \ref{ch01:blockchain-applications}, большинство блокчейн-систем представляют из себя распределенные базы данных. В следствии этого, для построения модели блокчейн-системы, следует начать с формализации состояния базы данных, способа его изменять.

\begin{code}[language=Haskell,label=lst:statep,caption={Структура состояния системы}]
import qualified Data.Map as M
import           Data.Map (Map)

newtype Prefix = Prefix Int
type Prefixed k = (Prefix, k)

type StateP id value = Map (Prefixed id) value -- Portion of state
\end{code}

Тип `StateP` выражает тип состояния системы. Причем как глобального состояния целиком, так и его части.
Состояние представляется как словарь, отображение из ключа `(Int, id)` в значение `value`. Целочисленный префикс ключа введен для удобства дальнейшего построения.

И ключ, и префикс введены как абстрактные типы. Это означает, что для описания модели нам не требуется указывать, какой именно тип имеет ключ или значение. При описании работы с состоянием (в дальнейшем), будут накладываться различные ограничения (требования) на ключ или значение. Для выражения ограничений в нотации будет использоваться конструкция языка Haskell тайп-класс, например:

\begin{code}[language=Haskell,label=lst:constraints-example,caption={Пример наложения ограничений на абстрактные переменные}]
getMonoidValue :: (Ord id, Monoid value)
                 => Prefixed id -> StateP id value -> value
getMonoidValue key stateP = maybe mempty (M.lookup key stateP)
\end{code}

В примере было наложено ограничение `Ord id` на ключ, выражающее требование существования линейного порядка на множестве всех ключей. В сигнатуре функции указано еще одно требование, `Monoid value`, требующее от `value` моноидальную структуру.

\subsection{Вид транзакции}

В листинге \ref{lst:changeset} формализовано изменение состояния.
Изменение словаря можно представить как тип-произведение из множества ключей,
которые требуется удалить `csRemove` и множества пар ключ-значение, которые требуется добавить в словарь `csAdd`.

\begin{code}[language=Haskell,label=lst:changeset,caption={Изменение состояния системы}]
data ChangeSet id value = ChangeSet
    { csAdd    :: Map (Prefixed id) value
    , csRemove :: Set (Prefixed id)
    }
\end{code}

Применение объекта типа `ChangeSet id value` к словарю должно иметь следующую семантику:

\begin{equation} \label{prop:bc_modify}
\begin{split}
& applyChangeSet\: (\: state : StateP, \: \langle csAdd, csRemove \rangle : ChangeSet \:) \enspace = \enspace
\\
& \quad 
     \begin{cases}
       \bot, \quad \text {if }
       \\ \quad\quad csRemove \cap keys(state) \neq csRemove 
       \\ \quad\quad\quad\quad \lor (keys(csAdd) \setminus csRemove) \cap keys(state) \neq \emptyset
       \\
       (state \setminus csRemove) \cap csAdd, \quad \text {otherwise}
    \end{cases} 
\end{split}
\end{equation}

Что замечательно, тип `Either e (ChangeSet id value)` является моноидом, где `e` -- некоторый тип ошибки. Это позволяет объединять множество транзакций в одно изменение типа `ChangeSet id value`, применяемое в дальнейшем к состоянию систему. Это свойство полезно для построения эффективной системы.

Транзакция к состоянию имеет следующий вид:

\begin{code}[language=Haskell,label=lst:tx,caption={Транзакция}]
newtype StateTxType = StateTxType Int

data StateTx id proof value = StateTx
    { txType  :: StateTxType
    , txProof :: proof
    , txBody  :: ChangeSet id value
    }
\end{code}

Помимо изменения состояния, транзакция содердит в себе еще два поля: `txType` и `txProof`.
Поле `txType` представляет из себя целочисленный идентификатор типа транзакции.
Поле `txProof` содержит в себе дополнительную информацию, требующуюся валидатору для проверки корректности транзакции.
В частности, для транзакции, изменяющей баланс пользовательского счёта, `txProof`, должен содержать подпись транзакции секретным ключом пользователя-владельца средств.

Оба поля будут использованы в последствии в построении валидатора.
Что существенно, поле `txBody` содержит в себе полный набор изменений, которые будут применены к состоянию системы. Ни `txProof`, ни `txType` не будут применены к состоянию, будут забыты как только валидатор их обработает.

\subsection{Валидация транзакции}

Простейший валидатор транзакции может быть описан функцией, имеющей одну из сигнатур:

\begin{code}[language=Haskell]
validator1 :: StateTx id proof value -> Bool
validator1 = ...

validator2 :: StateP id value -> StateTx id proof value -> Bool
validator2 = ...

validator3 :: StateTx id proof value -> (Set id, StateP id value -> Bool)
validator3 = ...
\end{code}

Функция `validator1` принимает транзакцию и возвращает `True` тогда и только тогда когда транзакция является корректной. Однако, только для очень небольшого класса транзакций можно выразить валидатор, используя функцию с такой сигнатурой. Реализация практически любой функциональности криптовалюты требует доступа валидатора к состоянию.

Функция `validator2` принимает на вход глобальное состояние системы. Функция позволяет выразить класс транзакций, чьи валидаторы требуют только доступа к состоянию системы для проверки транзакции. Такой класс достаточно широк для построения модели криптовалюты, однако использование такой сигнатуры функции является препятствием для построения эффективной реализации.

В существующих на сегодняшний день системах состояние системы измеряется в гигабайтах данных, передавать состояние как единый объект, полностью загруженный в оперативную память компьютера, является неэффективным
расходом ресурсов. Функция `validator3` в отличие от `validator2` не передаёт глобальное состояние как единый объект, но позволяет запросить интересующие ключи из состояния и возвратить результат валидации транзакции в соответствии с возвращенными значениями.

Однако `validator3`, как и `validator1`, описывает только узкий класс транзакций, в общем смысле для валидации транзакции может потребоваться сделать более одного запроса к глобальному состоянию. Например, для проверки отсутствия циклов в цепочке делегаций, требуется выполнить как минимум `maxDlgHeight` запросов к базе, где `maxDlgHeight` -- максимальная путь в ациклическом графе делегации (параметр делегации).
Процесс валидации делегационной транзакции будет подробно рассмотрен в разделе \ref{ch03:delegation}.

Введем несколько вспомогательных типов, чтобы выразить тип валидатора, позволяющего выразить класс транзакций, имеющих возможность запроса ключей из состояния произвольное количество раз, допускающего эффективную реализацию.
Воспользуемся концепцией свободной монады, определенной в языке Haskell (подробнее с концепцией свободных монад можно ознакомиться в документации к библиотеке free \citep{free-hackage}). Свободная монада определяется следующим типом данных:

\begin{code}[language=Haskell,label=lst:free-monad,caption={Свободная монада}]
data Free f a
  = Pure a
  | Free (f (Free f a))
\end{code}

Тип данных `Free` описывает чистую функцию, которая возвращает либо значение, либо запрос к внешнему контексту.
Тип `Free` определяет два конструктора: `Pure` и `Free`.
Конструктор `Pure` используется для возврата значения, конструктор `Free` для обращения к внешнему контексту с последующим продолжением вычисления.
Переменная типа `f` задаёт конкретный формат обращения к внешнему контексту и обработки результата обращения.

\begin{code}[language=Haskell,label=lst:dataaccess1]
newtype DataAccess1 req resp res = DataAccess1 (req, resp -> res)
  deriving (Monoid, Functor)
\end{code}

Тип `DataAccess1` представляет из себя пару, первым элементом которой является запрос к состоянию, вторым -- функция, которая принимает результат исполнения запроса и возвращает функцию продолжения вычисления. Подставив `req = Set id`, `resp = Map (Prefixed id) value`, мы получаем конктрукцию, достаточно экспрессивную для реализации валидатора, итеративно рассматривающего различные ключи состояния. В некоторых случаях этого ожет оказаться недостаточным, например если нам требуется запросить не
какой-то конкретный ключ, а все ключи, отвечающие какому-либо критерию. Воспользуемся префиксом: добавим возможность сделать запрос, который либо запрашивает множество ключей, либо проитерироваться всем ключам с префиксом $p$ в состоянии.

\begin{code}[language=Haskell,label=lst:data-access,caption={Функтор обращения к состоянию}]
data FoldF a res = forall b. FoldF (b, a -> b -> b, b -> res)

data DbAccess id value res
  = DbQuery (Set (Prefixed id)) (StateP id value -> res)
  | DbIterator Prefix (FoldF (id, value) res)
  deriving (Functor)

type StatePComputation id value = Free (DbAccess id value)

validator4 :: StateTx id proof value -> StatePComputation id value Bool
validator4 = ..
\end{code}

Тип `DataAccess` представляет из себя тип-сумму, первый конструктор которого эквивалентен `DataAccess1`, второй представляет из себя интерфейс для итерации по множеству ключей. Тип `FoldF` представляет произвольную функцию свёртки: начальное значение `b`, свёртка по очередному элементу `a -> b -> b` и конверсия результата в тип результата `res`.

Тип `StatePComputation`, сигнатура функции `validator4` показывают, как подстановкой `DataAccess` как параметра в тип `Free` можно получить конструкцию, подходящую для описания валидатора. Сигнатура `validator4` позволяет реализации запрашивать ключи из глобального состояния, получать соответствующие им значения, причем
делать это столько раз, сколько потребуется.

Окончательный тип валидатора транзакции предложен в листинге \ref{lst:validator}:

\begin{code}[language=Haskell,label=lst:validator,caption={Тип валидатора транзакции}]
newtype PreValidator e id proof value =
  PreValidator 
    (StateTx id proof value -> ExceptT e (StatePComputation id value) ())

newtype Validator e id proof value =
  Validator (Map StateTxType (PreValidator e id proof value))
\end{code}

Тип `ExceptT e (StatePComputation id value) ()` является непосредственным обобщением типа `StatePComputation id value Bool`, позволяющим в случае если валидация транзакции закончилась отрицательным результатом, указать ошибку типа `e` (а не просто `False`). Тип `PreValidator` является достаточным для описания логики валидации, в частности при проверке транзакции, он может рассматривать тип транзакции (поле `txType`), возвращать положительный результат в случае если транзакция является корректной
и ошибку в случае если предложенный тип транзакции не предназначен для проверки данным валидатором или если транзакция является некорректной.

Однако, для проверки множества транзакций требуется различать, какой валидатор относится к первому типу транзакции, какой ко второму и т.д., т.к. ошибка, возвращенная валидатором при проверки транзакции, тип которой не соответствует типу, рассматриваемым валидатором, не обязательно указывает на некорректность транзакции. Потому в дополнению к типу `PreValidator` введён тип `Validator`, соддержащий в себе отображение из типа транзакции в соответствующий типу валидатор.

На логику проверки транзакции с помощью объекта типа `Validator` накладывается ограничение, что проверяемый тип транзакции содержится в хранящемся в объекте отображении, иначе возвращается ошибка. Это требуется для того, чтобы исключить возможность положительного результата валидации транзакции, чей тип неизвестен валидатору.

В последующем изложении под термином валидатор будет пониматься объект типа `Validator`, описанный типом выше, под термином предвалидатор -- объект типа `PreValidator`.

\subsection{Моноидальная структура валидатора}

Важным свойством определенных выше валидатора, предвалидатора является их моноидальная структура. Рассмотрим подробнее определения моноидальной единицы, моноидального умножения для этих двух типов.

Моноидальная единица для предвалидатора реализуется просто: это предвалидатор, разрешающий всякую транзакцию. Аналогично для валидатора: единицей является тип, запрещающий всякую транзакцию (пустой ассоциативный массив из типа транзакции в предвалидатор).

Умножение для валидатора представляет из себя объединение двух ассоциативных массивов из типа транзакции в предвалидатор, причем при совпадении ключей, требуется воспользоваться моноидальным умножением для предвалидатора.

Умножение для предвалидатора сводится к умножению двух вычислений типа `ExceptT e (StatePComputation id value) ()`. Или, эквивалентно, `StatePComputation id value (Either e ())`. Соответствующими типу значениями могут быть: `Free dataAccess`, `Pure (Left e)`, `Pure (Right ())`. Если одно из значений `Pure (Left e)`, вычисление завершается ошибкой `e`, т.е. результат умножения -- `Pure (Left e)`. Если один из операндов умножения `Pure (Right ())`, результат умножения равен другому операнду.

Наконец, если мы имеем операнды `Free dataAccess1`, `Free dataAccess2`, следует произвести следующее:

* Если `dataAccess1 = DBQuery idSet1 cont1`, `dataAccess2 = DBQuery idSet2 cont2`, результат умножения будет равен `DBQuery idSet3 cont3`, где $idSet3 = idSet1 \cup idSet2$, $cont3 = \lambda values . cont1 \: (values \cap idSet1) \cdot cont2 \: (values \cap idSet2)$ (обозначение $\cdot$ используется для моноидального умножения).
* Если `dataAccess1 = DBIterator p (FoldF (init, foldf, resF))`, результат умножения будет `DBIterator p (FoldF (init, foldf, resF'))`, где $resF' = \lambda b . \: (resF \: b) \cdot (Free \: dataAccess2)$
* Аналогично для `dataAccess2 = DBIterator p f2`

Определенное таким образом моноидальное умножение обладает интересным свойством: соседствующие операнды `DBQuery idSet cont` будут объединены в один. Это означает что множество небольших запросов к состоянию будут объединены в один композитный запрос (что представляет собой распространенную и достаточно эффективную оптимизацию при работе с базами данных).

В дальнейшем при построении модели мы будем активно пользоваться моноиальной структурой валидатора и предвалидатора. Эта особенность позволяет описывать различные функциональности независимо друг от друга (посредством описания соответствующих предвалидаторов, валидаторов), а затем совмещать их вместе, используя моноидальное умножение.

\subsection{Валидация структуры транзакции}

Для проверки структуры транзакции на корректность (безотносительно к типу транзакции) следует выолнять проверки свойств, описанных в формуле \ref{prop:bc_modify}. Выполнение этих проверок объединим в предвалидатор `structuralPrevalidator`, которым мы воспользуемся в дальнейшем построении модели.
