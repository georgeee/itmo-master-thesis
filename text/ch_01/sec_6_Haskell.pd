\section{Система типов и синтаксис языка Haskell}

В формализации будет использоваться система типов языка Haskell, диалект компилятора GHC 8.0 \citep{ghc}. Диалект языка Haskell, поддерживаемый компилятором GHC 8.0 реализует систему FC с явным равенством видов \citep{system-fc-eke} \citep{system-fc-ghc}.
Таким образом, существует трансляция системы типов языка Haskell в систему типов FC с явным равенством типов. Решение придерживаться синтаксиса языка Haskell вместо нотации, принятой в работах по теории типов, продиктовано практическими соображениями, в том числе возможностью использовать компилятор GHC для проверки получаемых типов.

В описании модели и примерах будет использоваться ограниченное подмножество системы типов и синтаксиса языка Haskell, которые будут вкратце изложены в настоящем разделе.

В языке Haskell используются алгебраические типы данных. В листинге \ref{lst:alg-types} показан тип `ABC`, имеющий три конструктора. В случае когда функция принимает значение типа `ABC`, точно известно, что это значение создано одним из трех конструкторов и соответственно известно, какие значения храняться в нем. В определении типа `ABC` используются встроенные целочисленные типы `Int` и `Word32`.
Функция `func` показывает пример работы с алгебраическим типом `ABC`, в частности, преобразование его во встроенный тип `Int`.

В реализации функций на языке Haskell вызов функции происходит без применения скобочной нотации как во многих других языках программирования. Для вызова функции `f` с параметрами `5` и `8` требуется писать `f 5 8`, а не `f (5, 8)`.

Типы данных в Haskell могут быть полиморфными, как, например, тип `MyList`, представляющий собой непустой односвязный список, принимающий переменную типа `a` как параметр. В Haskell существуют синонимы типов, как, например, `MyListI` (синоним типов не декларирует новый тип, являясь только синтактическим сахаром). Ключевое слово `newtype` может использоваться для типа данных, в котором внутри содержится только одно значение другого типа данных и с точки зрения теории типов языка Haskell эквивалентно
использованию ключевого слова `data`.

Типы данных `Const`, `Maybe` и `Proxy` -- стандартные типы данных, чрезвычайно полезные в реализации многих вычислений. Тип списка также является стандартным типом, имеющим два конструктора: конструктор пустого списка `[]` и конструктор добавления элемента в начало списка `(:)`. Благодаря синтаксическому сахару можно писать `[12, 45, 78]`, что будет эквивалентно записи `12 : 45 : 78 : []`.
Кроме того, будут использоваться стандартные типы `Set v` и `Map k v`, представляющие собой множество и ассоциативный массив соответственно.

\begin{code}[language=Haskell,label=lst:alg-types,caption={Алгебраический тип данных}]
data ABC = A Int
         | B Word32 Word32
         | C AnotherData

data AnotherData = AD
      { adLeft :: Int
      , adRight :: Int
      }

func :: ABC -> Int
func (A i) = i
func (B i j) = fromIntegral ( i + j )
func (C (AD i j)) = i + j

data MyList a = MyEl a | MyCons a (MyList a)

type MyListI = MyList Int
newtype MyListW = MyListW (MyList Word32)

data Const a b = Const { unConst :: a }
data Proxy a = Proxy
data Maybe a = Just a | Nothing
\end{code}

Всякая функция в языке Haskell имеет однозначно определенный тип, который часто прописывается явно в строчке над определением функции (см. листинг \ref{lst:function-type}). Знак `=>` разделяет ограничения на тип функции и сам тип, знак `->` разделяет параметры функции (в Haskell активно применяется каррирование функций).
Обозначение `(..)` будет использоваться в листингах настоящей работы для обозначения участка кода, который опускается.
Сигнатуры типов поддерживают полиморфные типы и, более того, позволяют задавать ограничения на используемые типы.

\begin{code}[language=Haskell,label=lst:function-type,caption={Сигнатуры функций}]
func :: ABC -> Int
func (A i) = (..)

countUnique :: Eq a => MyList a -> Int
countUnique = (..)
\end{code}

В работе будет использоваться ряд стандартных ограничений: `Eq` -- для типа определена функция равенства, `Ord` -- для типа определены функции сравнения, `Semigroup` -- для типа определена моноидальная композиция, `Monoid` -- для типа определена моноидальная композиция и единица.
Новые ограничения могут создаваться либо посредством классов типов, либо посредством семейств типов.

При описании работы с состоянием (в дальнейшем), будут накладываться различные ограничения (требования) на ключ или значение. Для выражения ограничений в нотации будет использоваться конструкция языка Haskell «тайп-класс». В листинге \ref{lst:hasreview} определены классы `HasReview`, `HasPrism`, использующиеся для конструирования и деконструирования типов. Семейство типов `HasReviews` обобщает ограничение класса `HasReview` на случай списка типов, к которым ограничение должно применяться.

Классы типов представляют собой механизм для полиморфизма, позволяющий создать обобщенные функции, использующие переменные типов в своем определении, и предоставлять реализации этих функций отдельно для каждого конкретного типа (как, например, реализация класса `HasReview` для типов `Maybe a` и `a` в листинге \ref{lst:hasreview}).
Семейства типов являются способом задания функций на типах. 

\begin{code}[language=Haskell,label=lst:hasreview,caption={Класс типов $HasReview$}]
class HasReview s a where
    inj :: a -> s

class HasReview s a => HasPrism s a where
    proj :: s -> Maybe a

instance HasReview (Maybe a) a where
    inj = Just

type HasException = HasReview

type family HasReviews (e :: *) (exs :: [*]) where
    HasReviews e '[]    = (() :: Constraint)
    HasReviews e (e1:xs) = (HasReview e e1, HasReviews e xs)

type HasExceptions e xs = HasReviews e xs
\end{code}

В системе типов Haskell благодаря механизму поднятия типов каждый тип данных, определяющий значения, порождает вид,  определяющий типы. Это позволяет (в особенности с использованием семейств типов) создавать выразительные конструкции с участием произвольных видов. В частности это касается семейства типов `RecAll'`, определение которого представлено в листинге \ref{lst:recall}. Переменная `u`, используемая в определении `RecAll'` представляет некоторый произвольный вид.
Семейство типов `RecAll'` позволяет задавать ограничение `c` для всех типов из предложенного списка `rs`.

\begin{code}[language=Haskell,label=lst:recall,caption={Семейство типов $RecAll'$}]
type family RecAll' (rs :: [u]) (c :: u -> Constraint) :: Constraint where
    RecAll' '[] c = ()
    RecAll' (r ': rs) c = (c r, RecAll' rs c)
\end{code}

В листинге \ref{lst:hascap} заданы еще несколько семейств типов, которые будут активно использоваться в настоящей работе. Семейство `HasCap` позволяет проверять, что первый параметр явлется элементом второго параметра (списка типов). Семейство `NotIntersects` проверяет, что два списка типов не пересекаются.

\begin{code}[language=Haskell,label=lst:hascap,caption={Семейство типов $HasCap$}]
type family HasNoCap (cap :: k) (caps :: [k]) :: Constraint where
  HasNoCap cap (cap : cs) =
    TL.TypeError
      ('TL.Text "Capability " ':<>:
       'TL.ShowType cap ':<>:
       'TL.Text " is already present")
  HasNoCap cap (cap' : caps) = HasNoCap cap caps
  HasNoCap cap '[] = ()

type family HasCap (cap :: k) (caps :: [k]) :: Constraint where
  HasCap cap (cap  : cs) = ()
  HasCap cap (cap' : caps) = HasCap cap caps
  HasCap cap '[] =
    TL.TypeError
      ('TL.Text "Capability " ':<>:
       'TL.ShowType cap ':<>:
       'TL.Text " must be available")

type family HasNoCaps icaps caps :: Constraint where
  HasNoCaps '[] cs = ()
  HasNoCaps (icap : icaps) caps = (HasNoCap icap caps, HasNoCaps icaps caps)

type family HasCaps icaps caps :: Constraint where
  HasCaps '[] cs = ()
  HasCaps (icap : icaps) caps = (HasCap icap caps, HasCaps icaps caps)

type NotIntersects as bs = (HasNoCaps as bs, HasNoCaps bs as)
\end{code}

\subsection{Библиотека Vinyl}

\label{ch01-vinyl}

В определении модели состояния будет активно использоваться тип `Rec` из библиотеки Vinyl \citep{vinyl}. Тип `Rec` представлен в листинге \ref{lst:vinyl-rec} и представляет собой гетерогенный список записей, параметризованный типами хранимых в нем элементов.

\begin{code}[language=Haskell,label=lst:vinyl-rec,caption={Тип данных $Rec$}]
data Rec :: (u -> *) -> [u] -> * where
  RNil :: Rec f '[]
  (:&) :: !(f r) -> !(Rec f rs) -> Rec f (r ': rs)
\end{code}

В листинге \ref{lst:vinyl-ex} представлен пример использования типа `Rec` и альтернатива ему в стандартных алгебраических типах. Использование `Rec` предполагает использование ряда продвинутых механизмов системы типов языка Haskell, однако в некоторых случаях является необходимым для достижения желаемой выразительности системы типов.

\begin{code}[language=Haskell,label=lst:vinyl-ex,caption={Пример использования типа данных $Rec$}]
type MyData = Rec Set '[Int, Word32]

data MyData2 = MyData2 (Set Int) (Set Word32)
\end{code}
