\section{Аккаунтинг}

\label{ch04-accounting}

Существует две модели аккаунтинга, получившие наибольшее распространение в криптовалютах: аккаунтинг, поддерживающий UTxO записи и аккаунтинг, поддерживающий счета пользователей. Обе модели формализованы в терминах теории типов в работе Chimeric Ledgers \citep{chimeric-ledgers}, в настоящем разделе будут предложены практически идентичные формализации обоих моделей аккантинга на основе модели блокчейн-системы.

Для реализации криптовалюты можно использовать любую из них (возможна трансляция из одной модели в другую \citep{chimeric-ledgers}), описанные в настоящем разделе модели можно применять независимо друг от друга, причем другие функциональности блокчейн-системы в предлагаемых моделях блокчейн-системы и криптовалюты не зависят от выбора в пользу одной из моделей аккаунтинга.

\subsection{Аккаунтинг, поддерживающий UTxO записи}

Всякая транзакция в моделе аккаунтинга, поддерживающего UTxO записи, представляет из себя два списка: список входов типа `TxIn` и список выходов типа `TxOut`.
Вход представляет собой пару из идентификатора одной из ранее произошедших транзакций и индекса выхода в ней.
Выход представляет собой пару из адреса и количества монет, которые должны быть на этот адрес перечислены.

\begin{code}[language=Haskell,label=lst:utxo-types,caption={Типы UTxO аккаунтинга}]
data TxIn txId = TxIn
  { tiId    :: txId
  , tiIndex :: Int
  }

data TxOut addr coins = TxOut
  { toAddr  :: addr
  , toCoins :: coins
  }
\end{code}

Типы входа и выхода представлены в листинге \ref{lst:utxo-types} (в качестве типа `coins` можно поставить любой целочисленный тип), конструкция транзакции проиллюстрирована на рисунке \ref{img:utxo-tx}.

\image{utxo-tx}{Транзакции в UTxO аккаунтинге}

В моделе аккаунтинга, поддерживающий балансы пользователей посредством записей UTxO, состояние системы зранит отображение из объекта входа `TxIn` в объект выхода `TxOut` для всех выходов, которые еще не были использованы как входы какой-либо из транзакций.
Подсчёт баланса пользователя, т.е. суммы средств, принадлежащих адресу пользователя, включает итерацию по всем записям в отображении и фильтрацию записей, поле адреса в которых равно искомому.

\begin{code}[language=Haskell,label=lst:utxo-impl,caption={Реализация UTxO аккаунтинга}]
data UtxoTx = UtxoTxId

data UtxoTxSTag
type UtxoTxKV txId addr coins = '( TxIn txId, TxOut addr coins )

data UtxoTxValidationException id txId
    = TxInsAndTxOutsIntersect
    | NoWitness (TxIn txId)
    | InvalidWitness (TxIn txId)
    | InputsSumLessThanOutputsSum

data UtxoTxConfiguration mw rs proof witness = UtxoTxConfiguration
    { verifyWitness :: StateTx mw rs proof -> witness -> Bool
    }

type UtxoTxExtraction txId addr coins witness e mw rs =
    ( HasPrism proof (TxIn txId ~> witness)
    , HasException e StatePException
    , Ord (TxIn txId)
    , HasCap (StateTag UtxoTxSTag) rs
    )
\end{code}

\begin{code}[language=Haskell,label=lst:utxo-validator,caption={Валидатор UTxO транзакции}]
utxoTxValidator
    :: ( UtxoTxExtraction txId addr coins witness e mw rs proof
       , Num coins, Ord coins, Ord txId
       , IdStorage txIds UtxoTx
       , HasExceptions e
           [ UtxoTxValidationException id txId
           , StructuralValidationException id
           ]
       )
    => Proxy txIds
    -> UtxoTxConfiguration mw rs proof witness
    -> Validator e mw rs proof
utxoTxValidator p utxoConfig =
    mkValidator txType
        [ utxoTxStructuralPreValidator @txId @addr @coins @witness
        , witnessPreValidator @txId @addr @coins utxoConfig
        , sumInputsNotLessOutputsPreValidator @txId @addr @coins @witness
        ]
  where
    txType = StateTxType ( getId (Proxy @txIds) UtxoTxId )

\end{code}

В листингах \ref{lst:utxo-impl}, \ref{lst:utxo-validator} представлен фрагмент реализации UTxO аккаунтинга, использующая модель блокчейн-системы. Интересно, что валидатор UTxO транзакции разбивается на несколько предвалидаторов, которые объединяются, используя определения моноидальной композиции для типа.

\subsection{Аккаунтинг, поддерживающий счета пользователей}

Аккаунтинг, поддерживающий счета пользователей, хранит значения балансов пользователей непосредственно (а не опосредованно, как это делается в модели аккаунтинга UTxO). Транзакция представляет собой изменение в балансах аккаунтов. Помимо баланса, каждый аккаунт хранит целочисленное значение $nonce$, являющееся счётчиком операций, совершенных с аккаунтом. Для подтверждения операции над аккаунтом, транзакция, стремящаяся потратить средства с аккаунта, должна использовать большее значение $nonce$,
чем использованное ранее для данного аккаунта.

\begin{code}[language=Haskell,label=lst:account-types,caption={Типы аккаунтинга, поддерживающего счета пользователей}]
data AccountTx = AccountTxId

newtype AccountId addr = AccountId addr

data Account coins = Account
    { aBalance :: coins
    , aNonce   :: Int
    }

data AccountTxSTag
type AccountTxKV addr coins = '( AccountId addr, Account coins )

\end{code}

В листинге \ref{lst:account-types} представлены типы, использующиеся аккаунтингом, поддерживающего счета пользователей. В состоянии хранится отображение из адреса (тип `AccountId addr`) в тип `Account coins`. Более подробное рассмотрение реализации будет опущено, т.к. практически полностью повторяет реализацию UTxO аккаунтинга.

\subsection{Взаимосвязь аккаунтинга и метода доказательства доли владения}

В методе доказательства доли владения используется понятие доли владения -- пропорции в которой тот или иной участник системы владеет системой.
Стандартным подходом в реализации систем, построенных с использованием метода PoS является ассоциация долей владения с балансами в аккаунтинге. Т.е. $stake\;(u)\equiv \frac{balance\;(u)}{total \; balance}$, что является логичным развитием идеи доли владения.

Однако в реализации такой ассоциации легко допустить ряд ошибок. В предыдущих разделах не рассматривалось представление адресов, транзакций в виде сериализованных значений (т.к. рассмотрение подобных подробностей в целом выходит за рамки настоящей работы), в настоящем подразделе мы рассмотрим представление адреса в транзакции и введем соответствующее представление адреса в системе с аккаунтингом, основанной на алгоритме консенсуса, реализующем метод PoS.

Всякая транзакция хранит в себе объект типа `proof` и в случае аккаунтинга этот объект содержит доказательство корректности списания средств с адреса автором транзакции. Это доказательство в простейшем случае представляет собой цифровую подпись, сделанную ключом автора транзакции.
Причем адрес, на котором лежат средства в таком случае представляет собой значение применения некоторой криптографически-стойкой хэш-функции к ключу автора:
$Addr \equiv Hash\; PublicKey$, $validate \; ( pk, \; Proof \{ signature \}) = verify\; ( pk, \; signature)$. Публичный ключ "оборачивается" в хэш-функцию для получения адреса из соображений безопасности: в случае взлома схемы электронной подписи, списать средства с адреса будет по-прежнему практически невозможно, по крайней мере пока также не будет найдена уязвимость в строении хэш-функции.

Если ассоциировать балансы и доли владения наивным образом, т.е. подписывать блоки ровно тем же ключом, на соответствующих которому адресах хранятся средства, эта дополнительная защита в виде хэширования теряет свою функцию: при создании блока публичный ключ адреса, на котором хранятся средства, будет опубликован. От данного упущения в частности страдают криптовалюты EOS \citep{eos-white}, NEM \citep{nem-white} (спецификации которых рассмотрены в разделе \ref{ch01-cryptos}).

Единственным способом поддерживать те же гарантии безопасности в криптовалюте с аккаунтингом, основанной на PoS методе, является разделение секретных ключей.
Один ключ, ассоциированный с балансом ("балансовый" ключ) позволяет владельцу манипулировать его счётом, посылая денежные транзакции.
Другой ключ, ассоциированный с долей владения ("стейковый" ключ) позволяет владельцу манипулировать его долей владения (например, совершать делегационные транзакции), выпускать блоки, используя его долю владения.

Однако, адрес по-прежнему должен ссылаться как на балансовый ключ, так и на стейковый ключ. Причем публичная компонента стейкового ключа может быть раскрыта, тогда как публичная компонента балансового ключа раскрыта быть не должна. В листинге \ref{lst:stake-balance}, а также на рисунке \ref{img:stake-balance} представлено строение адреса, отвечающего поставленной задаче.


\begin{code}[language=Haskell,label=lst:stake-balance,caption={Адрес, ссылающийся и на стейковый, и на балансовый ключи}]
type Hash x = (...)

newtype StakePk = StakePk (...)
newtype BalancePk = BalancePk (...)


type Address = (StakePk, Hash (BalancePk, StakePk))
\end{code}

\image{stake-balance}{Адрес, ссылающийся на стейковый, и на балансовый ключи}

Предлагаемая схема репрезентации адреса реализует поставленную задачу: стейковый ключ общедоступен, балансовый ключ -- нет.
В данной схеме балансовый ключ будет раскрыт только в момент процессинга транзакции, переводящей средства на другой адрес.
Также следует заметить, что невозможно использовать в качестве стейкового публичного ключа, указанного в адресе, стейковый ключ, не соответствующий хэшу.
Такой адрес будет принят системой, однако расходовать средства с него не будет возможно
(возможность подстановки произвольного стейкового ключа в адрес была сделала бы возможным проведение ряда атак, изложение которых выходит за рамки настоящей работы).
